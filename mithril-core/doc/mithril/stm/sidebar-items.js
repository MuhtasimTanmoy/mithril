window.SIDEBAR_ITEMS = {"struct":[["StmAggrSig","`StmMultiSig` uses the “concatenation” proving system (as described in Section 4.3 of the original paper.) This means that the aggregated signature contains a vector with all individual signatures."],["StmAggrVerificationKey","Stm aggregate key, which contains the merkle tree root and the total stake of the system."],["StmClerk","`StmClerk` can verify and aggregate `StmSig`s and verify `StmMultiSig`s. Clerks can only be generated with the registration closed. This avoids that a Merkle Tree is computed before all parties have registered."],["StmInitializer","Initializer for `StmSigner`. This is the data that is used during the key registration procedure. Once the latter is finished, this instance is consumed into an `StmSigner`."],["StmParameters","Used to set protocol parameters."],["StmSig","Signature created by a single party who has won the lottery."],["StmSigner","Participant in the protocol can sign messages. This instance can only be generated out of an `StmInitializer` and a `ClosedKeyReg`. This ensures that a `MerkleTree` root is not computed before all participants have registered."]],"type":[["Index","Quorum index for signatures. An aggregate signature (`StmMultiSig`) must have at least `k` unique indices."],["Stake","The quantity of stake held by a party, represented as a `u64`."],["StmVerificationKey","Wrapper of the MultiSignature Verification key"],["StmVerificationKeyPoP","Wrapper of the MultiSignature Verification key with proof of possession"]]};