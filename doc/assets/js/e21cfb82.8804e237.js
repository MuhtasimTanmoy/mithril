"use strict";(self.webpackChunkmithril_doc=self.webpackChunkmithril_doc||[]).push([[1094],{7320:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"1","metadata":{"permalink":"/doc/adr/1","source":"@site/adr/001-use-adr.md","title":"1. Record Architecture Decisions\\n","description":"Status","date":"2022-11-28T09:31:05.000Z","formattedDate":"November 28, 2022","tags":[{"label":"Accepted","permalink":"/doc/adr/tags/accepted"}],"readingTime":0.515,"hasTruncateMarker":false,"authors":[],"frontMatter":{"slug":"1","title":"1. Record Architecture Decisions\\n","authors":[],"tags":["Accepted"]},"nextItem":{"title":"2. Use simple structured logging\\n","permalink":"/doc/adr/2"}},"content":"## Status\\n\\nAccepted\\n\\n## Context\\n\\nWe are in search for a means to describe our technical architecture.\\n\\nWe are a small team working in a very lean and agile way (XP), so we naturally\\nprefer also light-weight documentation methods which also accomodate change\\neasily.\\n\\n## Decision\\n\\n* We will use _Architecture Decision Records_, as described by Michael Nygard in\\n  this\\n  [article](http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions).\\n* We will follow the convention of storing those ADRs as Markdown formatted\\n  documents stored under `docs/adr` directory, as exemplified in Nat Pryce\'s\\n  [adr-tools](https://github.com/npryce/adr-tools). This does not imply we will\\n  be using `adr-tools` itself.\\n\\n## Consequences\\n\\nSee Michael Nygard\'s article, linked above."},{"id":"2","metadata":{"permalink":"/doc/adr/2","source":"@site/adr/002-use-structured-logging.md","title":"2. Use simple structured logging\\n","description":"Status","date":"2022-11-28T09:31:05.000Z","formattedDate":"November 28, 2022","tags":[{"label":"Draft","permalink":"/doc/adr/tags/draft"}],"readingTime":0.665,"hasTruncateMarker":false,"authors":[],"frontMatter":{"slug":"2","title":"2. Use simple structured logging\\n","authors":[],"tags":["Draft"]},"prevItem":{"title":"1. Record Architecture Decisions\\n","permalink":"/doc/adr/1"},"nextItem":{"title":"3. Release process and versioning\\n","permalink":"/doc/adr/3"}},"content":"## Status\\n\\n**Draft**\\n\\n## Context\\n\\n* Logs are a critical tool for operating any software system, enabling [observability](https://cloud.google.com/architecture/devops/devops-measurement-monitoring-and-observability) of the system.\\n* Following [12 Factor Apps](https://12factor.net/logs) principles, providing the needed components and tools to be able to configure logging and monitoring should not be the responsibility of the software components\\n\\n## Decision\\n\\n_Therefore_\\n\\n* Each component of the system use [Structured logging](https://www.sumologic.com/glossary/structured-logging/) using documented and standardised JSON format for its logs\\n* Logs are always emitted to `stdout` of the process the component is part of\\n\\n## Consequences\\n\\n* The schema of the logged items should be properly documented in a JSON schema\\n* It is the responsibility of the node operator to consume the logs and process them\\n* We use existing libraries to provide needed log infrastructure, like [slog](https://zsiciarz.github.io/24daysofrust/book/vol2/day4.html) for Rust"},{"id":"3","metadata":{"permalink":"/doc/adr/3","source":"@site/adr/003-release/index.md","title":"3. Release process and versioning\\n","description":"Status","date":"2022-11-28T09:31:05.000Z","formattedDate":"November 28, 2022","tags":[{"label":"Draft","permalink":"/doc/adr/tags/draft"}],"readingTime":2.995,"hasTruncateMarker":false,"authors":[{"name":"Mithril Team"}],"frontMatter":{"slug":"3","title":"3. Release process and versioning\\n","authors":[{"name":"Mithril Team"}],"tags":["Draft"]},"prevItem":{"title":"2. Use simple structured logging\\n","permalink":"/doc/adr/2"}},"content":"## Status\\n\\n**draft**\\n\\n## Context\\n\\nIn order to deliver regularly the software to our users, we should implement a release process based on a predictable versioning scheme. \\n\\n### Versioning\\n\\nA Release Version determines a distribution of determined node versions and underlying libraries.\\n\\n * Our softwares must be able to interact seamlessly with other Mithril software.\\n * Our softwares must be able to be hosted on crates.io.\\n * Our softwares must clearly indicate compatibility with other Mithril components to end users.\\n \\n\\n### Release process\\n\\nA Release is a software package that is built once and then promoted from the testing environment to the production environment. It can be signed.\\n\\n * Keep it simple.\\n * Automated as much as possible: all points not requiring human decision shall be automated.\\n * Minimize the mean time to release.\\n\\n## Decision\\n\\nThere are 3 versioned layers in the Mithril stack:\\n\\n * HTTP API protocol to ensure compatibility in the communication between nodes (use Semver).\\n * Crate version: each node & library has its own version (use Semver). The commit digest is automatically added to the version by the CI pipeline.\\n * Release Version: the distribution version (use version scheme **YYWW.patch** | **YYWW.patch-name**). The VERSION file is computed by the pipeline from the tag release.\\n\\nThe documentation is tied to a Release Version.\\n\\n### Release Process\\n\\nStarting just after a new release has been made:\\n\\n1. Develop on a dedicated development branch.\\n1. When merging PR on main: update the `Cargo.toml` files with version of the updated nodes.\\n1. Once merged, the CI creates an `unstable` tag & release which is deployed on testing environment.\\n1. Push a tag using the distribution version format on this commit with a `-prerelease` suffix.\\n1. The CI gets the built artifacts associated with this commit and generates a named pre-release which is deployed on `pre-release` for testing.\\n1. Push a tag using the distribution version format on this commit without the `-prerelease` suffix.\\n1. The CI gets the built artifacts associated with this commit and generates a named release which is deployed on `pre-release` for testing.\\n1. In the release GitHub interface, edit the newly generated release, uncheck the `This is a pre-release` checkbox.\\n1. The CI gets the built artifacts associated with this commit and generates a named release which is deployed on `release`.\\n1. Create a commit:\\n   1. to promote the documentation website from future to current.\\n   1. to update the SQL schema with alterations from the previous release.\\n\\n[![Release Process](./img/release_process.jpg)](./img/release_process.jpg)\\n\\n### Hotfix Release\\n\u200b\\nIn case of a blocking issue (following a distribution release) on the release environment that requires an immediate fix:\\n\u200b\\n1. Create a branch on the last release tag with the following scheme: **hotfix/{last_distribution-version}.{last_patch_number + 1}**.\\n1. Development of the fix is done on this branch.\\n1. After each commit on this branch, the CI creates an `unstable` tag & release which is not deployed on testing environment (testing must be done on an ad hoc environment manually created).\\n1. Push a tag on the branch last commit using the branch distribution version with a `-hotfix` suffix.\\n1. The CI gets the built artifacts associated with this commit and generates a named pre-release which is deployed on `pre-release` for testing.\\n1. In the release GitHub interface, edit the newly generated release, uncheck the `This is a pre-release` checkbox.\\n1. The CI gets the built artifacts associated with this commit and generates a named release which is deployed on `release`.\\n1. Merge the hotfix branch on main branch (and adapt the changes if they are not compatible with the current main branch)."}]}')}}]);