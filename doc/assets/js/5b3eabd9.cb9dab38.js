"use strict";(self.webpackChunkmithril_doc=self.webpackChunkmithril_doc||[]).push([[764],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),h=a,p=d["".concat(s,".").concat(h)]||d[h]||m[h]||o;return n?r.createElement(p,i(i({ref:t},u),{},{components:n})):r.createElement(p,i({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1774:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return m}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],l={sidebar_label:"Design",sidebar_position:2},s="Mithril Test Lab Design",c={unversionedId:"mithril/test-lab/test-lab-design",id:"mithril/test-lab/test-lab-design",title:"Mithril Test Lab Design",description:"Summary",source:"@site/root/mithril/test-lab/test-lab-design.md",sourceDirName:"mithril/test-lab",slug:"/mithril/test-lab/test-lab-design",permalink:"/doc/mithril/test-lab/test-lab-design",editUrl:"https://github.com/input-output-hk/mithril/tree/main/docs/root/root/mithril/test-lab/test-lab-design.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_label:"Design",sidebar_position:2},sidebar:"mithrilSideBar",previous:{title:"Overview",permalink:"/doc/mithril/test-lab/test-lab-overview"},next:{title:"Adversarial Events",permalink:"/doc/mithril/test-lab/mithril-adversarial-scenarios"}},u={},m=[{value:"Summary",id:"summary",level:2},{value:"Goals",id:"goals",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Model Specification",id:"model-specification",level:2},{value:"Attack Model Specification",id:"attack-model-specification",level:2},{value:"Controllable Reference Nodes",id:"controllable-reference-nodes",level:2},{value:"Heterogeneous Nodes",id:"heterogeneous-nodes",level:2}],d={toc:m};function h(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"mithril-test-lab-design"},"Mithril Test Lab Design"),(0,o.kt)("h2",{id:"summary"},"Summary"),(0,o.kt)("p",null,"The overall goal of the Mithril test lab is simple. We wish to develop a framework that can assess the correctness of\nMithril nodes, as well as their resistance to certain classes of attacks."),(0,o.kt)("p",null,"The best solution of this problem involves attacking an open question in concurrent systems correctness research: Can we\nbuild a unified framework that combines abstract modelling and reasoning with implementation correctness checks or\nguarantees?"),(0,o.kt)("h2",{id:"goals"},"Goals"),(0,o.kt)("p",null,"The test lab should stand as a method for immediately testing and assessing node implementations. In order, the test-lab\nshould be able to answer the following about a node or collection of nodes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Does it appear to have implemented the necessary functionality?"),(0,o.kt)("li",{parentName:"ul"},"Can it participate correctly in a well-functioning network?"),(0,o.kt)("li",{parentName:"ul"},"Is it resilient against any accidental or random failures?"),(0,o.kt)("li",{parentName:"ul"},"Can it withstand specific attacks agains the protocol or crytography?")),(0,o.kt)("p",null,"The test-lab should be depolyable by anyone who might want to deploy their own node, and programmable by anyone who\nmight want to program a node. An example of things that a programmer might ask the test lab to do is:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Does this network succesfully produce a correct signature in n seconds?"),(0,o.kt)("li",{parentName:"ul"},"If a node lies about their stake, will other nodes still include them in a signature output?"),(0,o.kt)("li",{parentName:"ul"},"If a cryptographic value is replaced, will a valid signature still be produced eventually?"),(0,o.kt)("li",{parentName:"ul"},"What happens if two nodes try to use the same public key?"),(0,o.kt)("li",{parentName:"ul"},"If we adjust the stake held by malicious nodes, at what point are they able to create an invalid signature?")),(0,o.kt)("p",null,"Another use for the test lab is in debugging. In general, concurrent systems are very hard to debug. The test lab should\ndo its best to recreate traces of events so that when a failure occurs, a programmer can step through precisely what\nhappened to cause it. If the test-lab is controllable enough, it might also eventually be able to replay traces in a\ndebug mode, so that the failing implemenation can be observed directly in the failing condition."),(0,o.kt)("h2",{id:"architecture"},"Architecture"),(0,o.kt)("p",null,"For the test lab to operate, we need to be able to do the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Specify a model of the intended behavior of the system"),(0,o.kt)("li",{parentName:"ul"},"(Optional/long term) Check those models and prove correctness"),(0,o.kt)("li",{parentName:"ul"},"Specify attacks or problems that we want to test"),(0,o.kt)("li",{parentName:"ul"},"Present a network layer that can be controlled and observed"),(0,o.kt)("li",{parentName:"ul"},"Transform the models into observations and actions on the network"),(0,o.kt)("li",{parentName:"ul"},"Orchestrate nodes to run and participate over the network"),(0,o.kt)("li",{parentName:"ul"},"Track the behavior of nodes under test to explain what has gone wrong")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502Model Checkers\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                       \u2502\n                          \u2502                               \u2502\n                     Verified by                Can imply safety from\n                          \u2502                               \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502System Model\u2502                \u2502 Attack Model \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502                               \u2502\n             Implemented in or layered on     Implemented in or layered on\n                          \u2502                               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Errors with traces\u25c4\u2500\u2500\u2524Monitors\u2502               \u2502Stream Transformers\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        Observe                         Control\n                          \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n                          \u2514\u2500\u2500\u25baTest Lab Network Layer\u25c4\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2518\n                                   \u2502          \u2502\n                       Drive Behavior    Communicate Over\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502          \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502Controllable Reference Nodes\u25c4\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2524Heterogeneous production nodes\u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,o.kt)("h2",{id:"model-specification"},"Model Specification"),(0,o.kt)("p",null,"We have chosen ",(0,o.kt)("em",{parentName:"p"},"monitors")," for the underlying representation of the system model. Monitors consume traces and emit errors\nif they are discovered. We are not currently certain if this is the best approach, instead monitors might want to emit\nstreams as well, which would allow for layering of monitors as well as the same underlying representations for\nattacks/tests and models."),(0,o.kt)("p",null,"The main benefit of monitors is that they're conceptually straightforward for engineers to understand. A monitor is just\na program about a trace. Monitors can be composed in various ways that should largely be comfortable to programmers.\nThey can be programmed in ways programmers are familiar with, instead of tying models to e.g. CSP or LTL. This works in\nour solution because we will mainly be reasoning over concrete states rather than abstract ones."),(0,o.kt)("p",null,"While having the full power of Haskell available for monitor creation is a great upside, the downside is that they will\nnot be readily suitable for any form of model checking. State-based representations, for example, provide a more\nconcrete syntax that can be introspected on and reasoned about by model checkers."),(0,o.kt)("p",null,'The flexibility of monitors however, could allow us to "split the difference". It should be possible to compile an\nexisting, checkable language such as P, Ivy, or TLA+ into a monitor representation. It would then be possible to\nmodel-check the high-level language, but use the monitors for execution.'),(0,o.kt)("h2",{id:"attack-model-specification"},"Attack Model Specification"),(0,o.kt)("p",null,"We expect to model attacks, or any kind of problem as transformations over the stream travelling over the network. This\nwill capture both random perturbations of data, as well as sophisticated, reactive attacks. Again, it should be possible\nto layer other languages on top of this abstraction. In general making these languages a domain-specific as possible\nshould also tend to make them more usable."),(0,o.kt)("h2",{id:"controllable-reference-nodes"},"Controllable Reference Nodes"),(0,o.kt)("p",null,"A wide range of both correct and incorrect behaviors are required to fully test the implementation of any network\nprotocol. Generating a wide range of correct behaviors can be done by simply creating an impelmentation that we believe\nto be correct. This implementation can often be implemented in a simpler manner than a production implementation in\norder to maximise its assurance. The correct implementation can then be used as a reference to check the behaviors and\nresults of other implementations."),(0,o.kt)("p",null,'A more complicated problem is how to generate incorrect behaviors. Arbitrary or naive errors are quite easy to generate\nby transformign or mutating impelementations at the bit level. Such modifications can be effective in finding problems,\nhowever they rely on random luck to trigger implementation bugs. Furthermore, reasoning about the wire-representation of\nmessages can be very painful for individuals that are used to thinking about messages as data-structures. In other\nwords, an engineer would rather write "leave field A of Record B out completely" than write "delete bits N..N+L from\nthis message, where N is calcualted from information about the rest of the message". Unfortunately, most correct\nimplementations can make it completely impossible to generate messages that are incorrect, particularly messages that\nviolate data-structure invariants.'),(0,o.kt)("p",null,'This exposes another requirement of a useful "reference implementation" which is to make it as controllable as possible.\nThat is, it should not only be useable as a correct reference, but it should be able to simulate almost any attacker\nneeded when required, either by generating subtly incorrect messages, or generating correct messages with ',(0,o.kt)("em",{parentName:"p"},"meaninguflly"),"\nincorrect contents. In the case of Mithril, this could constitute dishonest state representations or cryptograpically\ndifficult values."),(0,o.kt)("p",null,"An open design question is if this kind of behavior should be built into a controllable reference node or if it can be\nbuilt as a powerful transformation layer on top of a correct reference node. Keeping them separate results in a more\npurely correct reference node, which is valuable if it will be used as an implementation reference. Keeping the layers\nseparate ",(0,o.kt)("em",{parentName:"p"},"might")," result in a less powerful attack capability, or at least higher difficulty in coordinating more\nsophisticated attacks on the protocol under test."),(0,o.kt)("h2",{id:"heterogeneous-nodes"},"Heterogeneous Nodes"),(0,o.kt)("p",null,"A node being tested will need:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"To be programmed over an abstract network that can be replaced with the test lab network,"),(0,o.kt)("li",{parentName:"ul"},"To have implemented any APIs required by the specification of the protocol it implements,"),(0,o.kt)("li",{parentName:"ul"},"If the protocol specifies any optional API requirements, implementing those will result in better test output")),(0,o.kt)("p",null,"Any node implemented in this way shold be able to be tested by the test lab. There will be an additional per-language\nrequirement for the test-lab to implement bindings to its network layer in each languages nodes under test will be\nimplemented in. Initially this will be done for Rust and Haskell."),(0,o.kt)("p",null,"We mention optional APIs because it might be useful for nodes being debugged to present more information about their\nstate. This will allow for more immediate and useful error traces if, for example, a node makes an incorrect decision\nthat would not be immediately observable on the network. In general, such APIs should not require any sensitive\ninformation from nodes, in case those APIs are accentially left on in production."),(0,o.kt)("p",null,"One mode the test lab will be useful in is simply watching a collection of heterogeneous nodes operating and monitoring\nfor any incorrect behavior."))}h.isMDXComponent=!0}}]);