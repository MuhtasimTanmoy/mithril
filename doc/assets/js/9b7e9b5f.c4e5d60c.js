"use strict";(self.webpackChunkmithril_doc=self.webpackChunkmithril_doc||[]).push([[897],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return p}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=c(n),p=a,g=d["".concat(l,".").concat(p)]||d[p]||u[p]||r;return n?i.createElement(g,o(o({ref:t},h),{},{components:n})):i.createElement(g,o({ref:t},h))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7173:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var i=n(7462),a=n(3366),r=(n(7294),n(3905)),o=["components"],s={},l="Mithril Certificate Details",c={unversionedId:"core-concepts/certificate-details",id:"core-concepts/certificate-details",title:"Mithril Certificate Details",description:"This document covers an open discussion on some important details required to",source:"@site/root/core-concepts/certificate-details.md",sourceDirName:"core-concepts",slug:"/core-concepts/certificate-details",permalink:"/doc/core-concepts/certificate-details",editUrl:"https://github.com/input-output-hk/mithril/tree/main/docs/root/root/core-concepts/certificate-details.md",tags:[],version:"current",frontMatter:{},sidebar:"coreConceptsSidebar",previous:{title:"Cardano APIs",permalink:"/doc/core-concepts/cardano-apis"},next:{title:"Simple Payment Verification",permalink:"/doc/core-concepts/spv"}},h={},u=[{value:"Role of the aggregator",id:"role-of-the-aggregator",level:2},{value:"Certificate granularity",id:"certificate-granularity",level:2},{value:"Not enough signatures",id:"not-enough-signatures",level:2},{value:"Signers know if not enough signatures were reached",id:"signers-know-if-not-enough-signatures-were-reached",level:3},{value:"How messages are obtained",id:"how-messages-are-obtained",level:2}],d={toc:u};function p(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"mithril-certificate-details"},"Mithril Certificate Details"),(0,r.kt)("p",null,"This document covers an open discussion on some important details required to\nbuild the certificates in general, and we give particular importance into how\nto create the certificate chain. More specifically, this document presents some\nideas on the following topic: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Role of the aggregator, "),(0,r.kt)("li",{parentName:"ul"},"Certificate granularity, "),(0,r.kt)("li",{parentName:"ul"},"Not collect enough signatures, and "),(0,r.kt)("li",{parentName:"ul"},"How messages to be signed are obtained,   ")),(0,r.kt)("p",null,"Open questions:"),(0,r.kt)("ul",{className:"contains-task-list"},(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ",'Define a rule to handle the case where we receive valid certificates for\ntwo different messages in a single "mithril epoch".'),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Define a rule to handle mithril skipping a full Cardano epoch. This is\nunlikelly, but we should define what to do in that case."),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Is it an undesirable burden for users to produce themselves the message\nto be signed?")),(0,r.kt)("h2",{id:"role-of-the-aggregator"},"Role of the aggregator"),(0,r.kt)("p",null,'What would happen if some aggregator claims not enough signatures were\nreceived? This doesn\u2019t really matter, as there will be a different\naggregator that will collect sufficient signatures and aggregate them\ninto a valid certificate. Similarly, different aggregators might have\ndifferent views of the signatures submitted (one aggregator might receive\n10 signatures, and a different one could receive 11), which would result\nin different certificates signing the same message. Again, this is not a\nproblem, as long as they certify the same message (we should specify\nwhat to do if we receive more than one message signed in the same\n"mithril epoch"). '),(0,r.kt)("p",null,"As a result, aggregator should not be responsible for distributing the\nsnapshot. There should be a separate entity that receives aggregated\ncertificates, and then distributes the snapshot."),(0,r.kt)("h2",{id:"certificate-granularity"},"Certificate granularity"),(0,r.kt)("p",null,"There is no requirements on the certificate granularity. However, it is\ndesirable that there always is ",(0,r.kt)("em",{parentName:"p"},"at least")," one certificate per new stake\ndistribution. Given that in Cardano the stake distribution is updated at\neach epoch, we should aim towards guaranteeing one valid certificate per\nepoch. However, given that certificate generation is pseudorandom, there\nexists the possibility of skipping some certificates (we present below\nthe probability of this happening). Therefore, having more than one\ncertificate per epoch seems a good option, specially because when bootstrapping\na new node, one only needs to verify one certificate per epoch. "),(0,r.kt)("p",null,"Recall that when you are bootstrapping you only really care about the\nsignature of the next stake distribution (and not about the state of the\nnode). Therefore, if we have more than one certificate per epoch, when we\nare bootstrapping we don\u2019t need to verify all these certificates. We only\nneed to verify the certificates that certify the next stake distribution,\nand not those that maintain the distribution of the previous certificate.\nA node that is bootstrapping only really needs to verify the first\ncertificate (or the last, really depends how we organise the message signed),\nof each different stake distribution, hence of each epoch. The other\ncertificates are not required, as what a node is doing while bootstrapping\nis verifying the stake changes to be able to validate the next certificate.\nTherefore, even if we produce 10 certificates per epoch, when a node is\nbootstrapping it can verify one certificate per epoch, until the last one,\nwhere it verifies all existing certificates."),(0,r.kt)("h2",{id:"not-enough-signatures"},"Not enough signatures"),(0,r.kt)("p",null,'As mentioned above, the creation of certificates is pseudorandom, so we\nmight find ourselves in a situation where the submitted signatures are not\nenough. As presented in the paper, the goal is to make the probability of this\nhappening as small as possible, while guaranteeing that an adversary will not\nbe able to generate invalid certificates. Table 2 of the paper is interesting\nto discuss this (it shows required values of k, n so that an adversarial\nquorum is formed with P \u2264 2 ^{\u2212128}). The table shows different values, but if\nwe take for instance \u03c6(.55), and assume adversarial stake of 40%, the\nprobability of reaching a quorum is 99.999% (assuming adversarial stake does not\nparticipate). If we consider an adversarial stake of 33%, then with \u03c6(.60) we\nwould reach a quorum with probability of 99.667%. We can also think of adversarial\nstake as nodes which are not available.\nNonetheless, what to do when these events happen, and we don\u2019t have a certificate.\nThe paper mentions the possibility of using a counter:\n"',(0,r.kt)("em",{parentName:"p"},"if the probability of an honest quorum remains significant it can be boosted by\nallowing retries (e.g by attaching a short counter to the message)"),'".',(0,r.kt)("br",{parentName:"p"}),"\n","However, there would also be the possibility of skipping a certificate, and\nsigning the next one. The probabilities of not reaching a quorum are so small\nthat it is unlikely that we will skip several blocks in a row. Skipping one (or\neven a few) block is not problematic (as long as we have one per epoch, in the\nopposite case we should reconsider what to do, as this becomes a bit uglier wrt\nlong range attacks)."),(0,r.kt)("p",null,"The other mitigation approach is to have a sort of hybrid parametrization, where\nwe would run a big (k,m) pair and a small one at the same time.\nIf aggregators can find enough signatures in the small param set, they prefer\nthat, if not they use the larger params. Might be clunkier for rewards though."),(0,r.kt)("h3",{id:"signers-know-if-not-enough-signatures-were-reached"},"Signers know if not enough signatures were reached"),(0,r.kt)("p",null,"If we allow signers to also be aggregators, and therefore listen and accumulate\nsignatures, then they will know how many are being received and whether the\nquorum is being reached or not. If we use the index solution proposed above,\na signer could get a grasp of whether the quorum is going to be reached or not, and start\ntrying with the next index. If we don\u2019t follow the index solution, then signers don\u2019t really\ncare whether the quorum was reached or not, they simply proceed with the next signature."),(0,r.kt)("h2",{id:"how-messages-are-obtained"},"How messages are obtained"),(0,r.kt)("p",null,"The message to be signed is chosen by the signer itself. It is not received\nexternally. If I\u2019m a signer, I should have sufficient information to select\nwhat message I need to sign--this is, the stake distribution and aggregate key,\nand the state of the node at the block number for which we are producing a\nsignature. Given that choosing the message is a deterministic procedure,\nall honest nodes will generate a signature for the same message. Following\nthis, there is no room for adversaries to request signatures for adversarial\nmessages, nor the need for signers to validate the message to be signed."),(0,r.kt)("p",null,"To guarantee that users have the same view of what is being signed, the\nsnapshots are created past ",(0,r.kt)("em",{parentName:"p"},"k")," blocks (security parameter), which already\ngives high guarantees we have reached consensus."))}p.isMDXComponent=!0}}]);