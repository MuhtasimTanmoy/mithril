"use strict";(self.webpackChunkmithril_doc=self.webpackChunkmithril_doc||[]).push([[444],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return p}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var c=n.createContext({}),s=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),f=s(a),p=i,b=f["".concat(c,".").concat(p)]||f[p]||h[p]||o;return a?n.createElement(b,r(r({ref:t},d),{},{components:a})):n.createElement(b,r({ref:t},d))}));function p(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=f;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var s=2;s<o;s++)r[s]=a[s];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}f.displayName="MDXCreateElement"},949:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return c},default:function(){return p},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return h}});var n=a(7462),i=a(3366),o=(a(7294),a(3905)),r=["components"],l={},c="Simple Payment Verification",s={unversionedId:"core-concepts/spv",id:"core-concepts/spv",title:"Simple Payment Verification",description:"* SPV has been around in bitcoin since day 1 as a technique to verify inclusion of transactions in blocks without",source:"@site/root/core-concepts/spv.md",sourceDirName:"core-concepts",slug:"/core-concepts/spv",permalink:"/doc/core-concepts/spv",editUrl:"https://github.com/input-output-hk/mithril/tree/main/docs/root/root/core-concepts/spv.md",tags:[],version:"current",frontMatter:{},sidebar:"coreConceptsSidebar",previous:{title:"Mithril Certificate Details",permalink:"/doc/core-concepts/certificate-details"}},d={},h=[{value:"Generating a proof for some transaction in bitcoind",id:"generating-a-proof-for-some-transaction-in-bitcoind",level:2},{value:"FAQ",id:"faq",level:2},{value:"Emulating SPV with Mithril",id:"emulating-spv-with-mithril",level:2}],f={toc:h};function p(e){var t=e.components,a=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,n.Z)({},f,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"simple-payment-verification"},"Simple Payment Verification"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"SPV has been around in bitcoin since day 1 as a technique to verify inclusion of transactions in blocks without\nverifying the whole block, and it is based on Merkle-tree proofs: Given a block header containing the root hash of the\nblock, a proof is a sequence of hashes representing a branch in the Merkle-tree, so verifying the proof amounts to\nverifying that recursively hashing each node in the sequence yields the root hash.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"This ",(0,o.kt)("a",{parentName:"li",href:"https://developer.bitcoin.org/devguide/operating_modes.html?highlight=spv#simplified-payment-verification-spv"},"page"),"\nintroduces SPV in contrast with full-node mode"),(0,o.kt)("li",{parentName:"ul"},'From a usage point of view, SPV can be used to answer to the question: "Is transaction with hash ',(0,o.kt)("inlineCode",{parentName:"li"},"abc")," part of\nblock ",(0,o.kt)("inlineCode",{parentName:"li"},"123"),'?" without having to download the full block. The answer is a proof of inclusion and if positive one\ncan then download the full block'))),(0,o.kt)("li",{parentName:"ul"},"However, to construct the proof one needs to know which transaction it is interested in and the details of the block,\nso this can only be done by ",(0,o.kt)("em",{parentName:"li"},"full nodes"),", hence SPV clients would need to find another mean to construct proofs which\nis impractical",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"SPV Clients ",(0,o.kt)("em",{parentName:"li"},"issuing")," transactions can use SPV to check their inclusion in blocks easily"),(0,o.kt)("li",{parentName:"ul"},"However if one wants to track funds from several wallets (eg. a desktop and a mobile one) then to keep this\ninformation in sync is difficult"))),(0,o.kt)("li",{parentName:"ul"},"To solve this problem, ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki"},"Bloom Filters")," have been\nproposed and implemented early on (the BIP-0037 proposal dates back to 2012) in nodes and in various Lightweight\nclients.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Most notably, Android wallets based on ",(0,o.kt)("a",{parentName:"li",href:"https://bitcoinj.org/"},"bitcoinj")," which are cited in the initial proposal"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://electrum.readthedocs.io/en/latest/faq.html#how-does-electrum-work"},"Electrum")," is another popular wallet\nthat uses SPV to verify transactions history. Electrum is ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/spesmilo/electrum"},"open-source")," and\ncoded in Python that also supports Lightning"),(0,o.kt)("li",{parentName:"ul"},"When connecting to a peer node, lightweight clients can create and populate a bloom filter ",(0,o.kt)("em",{parentName:"li"},"on the peer side"),",\nthen the peer checks every block's content against the filter (transaction signer, addresses,...) and send a proof\nof inclusion for transactions that do match."),(0,o.kt)("li",{parentName:"ul"},"The bloom filter can output ",(0,o.kt)("em",{parentName:"li"},"false positives")," so there is some small probability the client will download more\nblocks than needed, eg. retrieve a block that contains a transaction that did match the filter but was\nuninteresting"))),(0,o.kt)("li",{parentName:"ul"},"It ",(0,o.kt)("a",{parentName:"li",href:"https://jonasnick.github.io/blog/2015/02/12/privacy-in-bitcoinj/"},"has been found")," quickly those Bloom filters were\nactually problematic:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"They do not provide privacy as there are easy attacks that can leak the addresses the client is interested in"),(0,o.kt)("li",{parentName:"ul"},"Nodes providing filtering service are susceptible to DoS attacks with specially crafter Bloom filters"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki"},"BIP-0157"),"\nand ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki"},"BIP-0158")," have been proposed to mitigate those\nissues. The provide so-called ",(0,o.kt)("em",{parentName:"li"},"Block filters")," protocol which works roughly as follow:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Nodes can maintain several disting probabilistic compressed filters based on a technique\ncalled ",(0,o.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Golomb_coding#Rice_coding"},"Golomb-Rice Coding")),(0,o.kt)("li",{parentName:"ul"},"Light clients can query ",(0,o.kt)("em",{parentName:"li"},"filter headers")," on top of block headers, to know which filters a node maintain and then\nretrieve the filters themselves, checking inclusion of items of interest on the client side"))),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/lightninglabs/neutrino"},"Neutrino")," client is the reference implementation, and it\nseems ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/lightninglabs/neutrino/issues/225"},"used on mainnet")," actively although the README has a\ndisclaimer stating the opposite."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.wasabiwallet.io/why-wasabi/NetworkLevelPrivacy.html#full-node-by-default-block-filters-over-tor"},"wasabi"),"\nuses block filters over Tor to provide SPV feature while preserving privacy.\n",(0,o.kt)("a",{parentName:"li",href:"https://github.com/bitcoinknots/bitcoin"},"Bitcoinknots")," is a fork of bitcoin with a desktop wallet, not sure what the\ndifferences are"),(0,o.kt)("li",{parentName:"ul"},"SPV can also be used for sidechains pegging: ",(0,o.kt)("a",{parentName:"li",href:"https://blockstream.com/sidechains.pdf"},"https://blockstream.com/sidechains.pdf"),". The idea is to commit from\nmainchain to sidechain (and back) using SPV proof as part of the transaction so that both chains can verify the\nlegitimacy of the coins pegged.")),(0,o.kt)("h2",{id:"generating-a-proof-for-some-transaction-in-bitcoind"},"Generating a proof for some transaction in bitcoind"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'$ bitcoin-cli getbestblockhash\n00000000000000000003bdf6945bd7a7bea34585ab227ffc7c67715a363cb0c8\n$ bitcoin-cli getblock 00000000000000000003bdf6945bd7a7bea34585ab227ffc7c67715a363cb0c8\n....\n$ bitcoin-cli getrawtransaction 757faada852390732e7a5594a33c422fe0fe350acd22bc130c6f04834964e1bf true 00000000000000000003bdf6945bd7a7bea34585ab227ffc7c67715a363cb0c8\n...\n      }\n    }\n  ],\n  "hex": "01000000000102b2d1db9c4e77760c6455b80b2f17dff9a632a6f72f45b369d8fd6a0373371c8d0100000000ffffffff6e441290e472af49e7624602d85cb102ee9e1d1b145dcdf9a95790b38e2d62dd0000000000ffffffff0132ea0a000000000017a914d413cda9ed0f5da0e999faaafb733745b5a34b2f8702483045022100a7ab53c805ec30d3992935ab2377d065a8eddb9ece06a21e0e23546ccf383024022032d464ddba1945e75aa97c1f2e5056e7cc2bead839f89dca737f8f701190d87c0121039034647b3a86556398beef77ce25f6e443e8f91e8bc129f4aa074febaf7c3ddc0247304402202c6f92d6077e4b46388e6ff113b6c08ddfbf205aa35a0b2ca0d79416dc0229a702201a3e2dd5fae3f99eb7a549ae15133c7121ec73814cd13b15abb51ddd6794b9c90121021ed95a235418e076b099f2e6e4c9d5380c5836882efca78b33b7786e4cdd14d500000000",\n  "blockhash": "00000000000000000003bdf6945bd7a7bea34585ab227ffc7c67715a363cb0c8",\n  "confirmations": 1,\n  "time": 1632472393,\n  "blocktime": 1632472393\n}\n$ bitcoin-cli gettxoutproof \'["757faada852390732e7a5594a33c422fe0fe350acd22bc130c6f04834964e1bf"]\' 00000000000000000003bdf6945bd7a7bea34585ab227ffc7c67715a363cb0c8\n04000020d99d3c79b78c541f3a50e1ba50c4b109c4cb8099e3690b0000000000000000009fac806629705a0f86d7d8055b1bd82246feef57d3f53fe09f7374926e94f89e498d4d61ebd00e170d31cfe2e30100000a688e90e8ed22687d743526c05d4dd74a89a2dd25e1b736d2ed323e306a3c35e8d131b41295c4726dcabbe7408ad794aca07692c9e79928061e837009d95bed38cb3070366525cfb69c7c586d778dc169b744c7be38c6cd955cac517fd49eab834226a203d95628b4430caa69d58ef9fced9266d060e95e552bc8ced10b38eed3bfe1644983046f0c13bc22cd0a35fee02f423ca394557a2e73902385daaa7f757c46b30755ceef3948bd3152c2fdef7ff96d8571403dfaccea7f69296b9203974962c02a390fae91fff79fd538f6bd7fcda74f9e95c9fd74785ad11f597558fdc79ba43daf35785eb4376fb54c6f7ea0173b9d671bb64a41b4b2047671f6d1adb8c31b856327a87a20fb72b9a2ff3d6c1e0ccd7a942927bc87362e1a711c21093aef143ad59c7113be896b112074671c1931562e35334ea94b92e5e1325b270503bb3500\n')),(0,o.kt)("p",null,"The later hex-encoded bytestring is the MT proof that the txid is part of the given block."),(0,o.kt)("p",null,"Then one can verify the proof to retrive the transaction id:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'$ bitcoin-cli verifytxoutproof $(cat proof)\n[\n  "757faada852390732e7a5594a33c422fe0fe350acd22bc130c6f04834964e1bf"\n]\n')),(0,o.kt)("h2",{id:"faq"},"FAQ"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Do you see a difference between a SPV node and an SPV client or are they the same thing?")),(0,o.kt)("p",null,"As I understand it, a SPV node is really an SPV-enabled node, eg. a full node that at least can produce SPV proofs on\nrequest, and also can handle client filters whether\nthrough ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki"},"Bloom filters"),"\nor ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki"},"block filters"),". I am not aware of SPV-only nodes\nthat would not be clients, eg. leaves in the network, because to produce a proof one has to have the whole block(s) and\nnot only the headers."),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"What goes in the proof of inclusion or SPV proof?")),(0,o.kt)("p",null,"It's the \"branch\" of the Merkle Tree that leads to the root which is stored in the block header, ie. a sequence of\ntransaction hashes (transaction ids) along with their siblings. Given such a branch, one can compute the root hash it\nleads to by iteratively computing the hash at each node in the branch, given the previous hashes of the node's children.\nIf the computed and actual block hashes are the same then the transaction ",(0,o.kt)("em",{parentName:"p"},"must")," be in that block."),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"What is the MT protocol?")),(0,o.kt)("p",null,"Are they ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Merkle_tree"},"Merkle-tree"),"? I don't know of any ",(0,o.kt)("em",{parentName:"p"},"MT protocol"),"."),(0,o.kt)("ol",{start:4},(0,o.kt)("li",{parentName:"ol"},"Is there some more information about the size of an SPV node/ SPV client?")),(0,o.kt)("p",null,"Clients: ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.bitcoinsv.io/index.php/Simplified_Payment_Verification"},"This article")," and others mention a\ncurrent total block headers size of around 50MB. To this cost, one should add the size of the data the client is\ninterested in, eg. transactions and UTXO set."),(0,o.kt)("ol",{start:5},(0,o.kt)("li",{parentName:"ol"},"why is it hard for an SPV client to keep track of numerous wallets?")),(0,o.kt)("p",null,"I haven't read any specific article on this issue but I can imagine that as the number of addresses to track increases,\nso does the complexity of checking all of them at every block: Create or retrieve the filters, then retrieve the block(\ns) of interest if there's a hit, possibly trying again if it's a false positive..."),(0,o.kt)("ol",{start:6},(0,o.kt)("li",{parentName:"ol"},"I've read somewhere that not every SPV node keeps a UTXO state, is there more information about how they manage this?")),(0,o.kt)("p",null,"I don't know"),(0,o.kt)("ol",{start:7},(0,o.kt)("li",{parentName:"ol"},"Do you think this improved Bloom filters is something that we should explorer in the context of Mithril?")),(0,o.kt)("p",null,'Yes. I don\'t know if it makes sense cryptographically, but if we could in some way derive a certificate for each block\nfilter, given a global certificate, that would allow lightweight clients and full (or mithril-aware) nodes to interact\nthrough a similar protocol: Get a root certificate, verify it against previously known "Safe" state, then filter the\navailable UTXO set using deterministic block filters.'),(0,o.kt)("ol",{start:8},(0,o.kt)("li",{parentName:"ol"},"Why cannot we run plain SPV on Cardano?")),(0,o.kt)("p",null,"Cardano being a Proof-of-Stake chain has different tradeoffs when it comes to validating blocks. In bitcoin, the\nProof-of-Work puzzle is part of the header hence it's easy to limit verification process to headers. In Cardano,\nvalidity of a block depends on current stake distribution and knowing the stake distribution requires going through all\ntransactions in a block and update the stakes accordingly. Because the stake distribution is large, putting it in block\nheaders is also impractical."),(0,o.kt)("h2",{id:"emulating-spv-with-mithril"},"Emulating SPV with Mithril"),(0,o.kt)("p",null,"Actually, I think we could not use\nthe ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/hydra-poc/tree/master/merkle-patricia-tree"},"Merkle-Patricia Tree")," we've been\nbuilding for Hydra for that purpose:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Mithril certificate signs the root hash of a MPT built from the UTXO set",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Note the MPT can be built incrementally at each block/epoch, deleting and adding UTXO"),(0,o.kt)("li",{parentName:"ul"},"Perhaps it would make more sense to store transactions' id in a basic Merkle-Tree"))),(0,o.kt)("li",{parentName:"ul"},"Mithril nodes maintain block filters",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"We could use Golomb-Rice coded sets as proposed in BIP-0158 to provide compact filters"),(0,o.kt)("li",{parentName:"ul"},"Filters should index all addresses in the UTXO set, at least, to enable light clients to lookup transactions of\ninterest only"))),(0,o.kt)("li",{parentName:"ul"},"Clients can retrieve block filters and certificate, then request specific Transactions/Blocks",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"It's unclear what a light client would need, probably transactions are enough?"))),(0,o.kt)("li",{parentName:"ul"},"Mithril node sends requested UTXO/Transaction set along with proof it's part of the MPT",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"False positives are simply ignored"),(0,o.kt)("li",{parentName:"ul"},"The proof guarantees the UTXO/Transaction is in the root hence has been signed")))),(0,o.kt)("p",null,"I\nwrote ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/mithril/blob/29b0209ba90d39d02f366ca526485d2474935f5e/test/Mithril/FilterSpec.hs"},"some code"),"\nexperimenting with:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Storing the UTXO set in a Merkle-Patricia-Tree indexed by reference (transaction id + transaction index)"),(0,o.kt)("li",{parentName:"ul"},"Building a Bloom filter for addresses in the UTXO set")),(0,o.kt)("p",null,"Some basic measures I made, given a set of 10000 UTXO:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Utxo size (serialised) is: 151MB"),(0,o.kt)("li",{parentName:"ul"},"Bloom Filter size is: 32KB"),(0,o.kt)("li",{parentName:"ul"},"Proof size: 552B")))}p.isMDXComponent=!0}}]);