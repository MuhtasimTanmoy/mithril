<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Mithril Blog</title>
        <link>https://input-output-hk.github.io/doc/milestones/</link>
        <description>Mithril Blog</description>
        <lastBuildDate>Thu, 14 Apr 2022 13:58:47 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Milestone Report n°1]]></title>
            <link>https://input-output-hk.github.io/doc/milestones/2022-01-report</link>
            <guid>/2022-01-report</guid>
            <pubDate>Thu, 14 Apr 2022 13:58:47 GMT</pubDate>
            <description><![CDATA[This document is a summary of the situation of the Mithril project as of January 2022. It aims at providing a]]></description>
            <content:encoded><![CDATA[<p>This document is a summary of the situation of the Mithril project as of January 2022. It aims at providing a
comprehensive overview of:</p><ul><li>What's been done,</li><li>What conclusions we can draw from the various efforts undertaken,</li><li>What open questions remain, and</li><li>What could be the next steps.</li></ul><h1>Current State</h1><h2 class="anchor anchorWithStickyNavbar_mojV" id="code">Code<a class="hash-link" href="#code" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="mithril-library">Mithril library<a class="hash-link" href="#mithril-library" title="Direct link to heading">​</a></h3><ul><li>Mithril core library has been developed mainly by Galois through September and October 2021 (last commit
from <code>abakst@galois.com</code> is from November 2).<ul><li>The library weighs in at about 25K LOC</li></ul></li><li>Development has been monitored closely by Iñigo and Pyrros who reviewed all PRs and also provided significant
contributions in particular to provide some polishing on:<ul><li>Unit and integration tests</li><li>C API,</li></ul></li><li>The library exposes a C API for all its features and data structures allowing client code to manage the whole
protocol. It is built and packaged as a dynamically linked <code>libmithril.so</code> which can then linked against by thirdparty
code. It's been tested with Go when developing the Mithril node</li><li>The library is throughly tested thanks to:<ul><li>A large set of unit and property-based tests for individual functions and features (code coverage is 68.36%, with
903/1321 lines covered)</li><li>Integration tests demonstrating the full protocol in Rust,</li><li>C tests using <a href="https://github.com/google/googletest" target="_blank" rel="noopener noreferrer">gtest</a> checking C API and integration with the core Rust
library,</li><li>Tests are run in
the <a href="https://github.com/input-output-hk/mithril/tree/main/.github/workflowss/ci.yml" target="_blank" rel="noopener noreferrer">Continuous Integration</a>
process, both for Rust, C and Go parts,</li></ul></li><li>It is lacking user-facing "Get started" style documentation but the code is properly documented and
the <a href="https://github.com/input-output-hk/mithril/tree/main/mithril-core/examples" target="_blank" rel="noopener noreferrer">examples/</a> directory contains several
detailed examples covering the major use cases for the library.<ul><li>Documentation of the library is
published <a href="https://input-output-hk.github.io/mithril/mithril-core/doc/mithril/index.html" target="_blank" rel="noopener noreferrer">online</a></li></ul></li><li>Library contained an implementation Ad-hoc Threshold Multi Signatures for use in Sidechains. It has now moved to
its <a href="https://github.com/input-output-hk/atms" target="_blank" rel="noopener noreferrer">own repo</a>.</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="performance--optimisations">Performance &amp; Optimisations<a class="hash-link" href="#performance--optimisations" title="Direct link to heading">​</a></h4><ul><li>The library is single-threaded, no effort has been put into parallelizing any of the protocol's operations. However,
the protocol's state is maintained in data structures that share nothing (eg. <em>objects</em>) so parallelisation is
trvially achievable by duplicating data and running signing or other functions<ul><li>Proper parallelisation assessment still needs to be done in order to understand how the library can scale</li></ul></li><li>The library comes with some micro-benchmarks for the various atomic operations provided.<ul><li>The most expensive operation is the key registration process which is done only once, to setup the protocol's
state.</li><li>Signature verification for 256 signers takes on average 3.6ms</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="go-node">Go Node<a class="hash-link" href="#go-node" title="Direct link to heading">​</a></h3><ul><li>A Mithril node has been developed by Idyllic Vision in Go<ul><li>It's about 3K LOC</li></ul></li><li>This node was intended as a <em>Proof-of-Concept</em> development to validate the feasability of running Mithril (full) node
as a separate (Layer 2) solution. As such, the goal of this development was to demonstrate the Mithril library can be
used by something else than cardano-node to produce signed certificates for some realistically sized UTXO set</li><li>The target architecture has been documented in the <a href="/doc/topologies/mithril-architecture">Mithril Architecture</a>
document</li><li>The actual implementation has the following features:<ul><li>The signature generation process is <em>leader-based</em>: The signing process is initiated by a leader that creates a
message to sign and requests signatures from the other participants, then aggregates the result and broadcast
again the resulting certificates</li><li>The data is retrieved from a <a href="https://github.com/input-output-hk/cardano-db-sync" target="_blank" rel="noopener noreferrer">db-sync</a>
populated <a href="https://www.postgresql.org/" target="_blank" rel="noopener noreferrer">Postgres</a> database instance (data is extracted from a Testnet)</li><li>The Mithril nodes uses the same DB to store the produced certificates</li><li>The key generation and key registration process is handled in the Rust library but the whole configured signing <em>
Clerk</em> can be serialised on disk so that node can start from a known configuration</li><li>The stakes distribution is statically defined in a configuration file and does not change over the life of the
nodes</li><li>The node exposes a classical REST API that allows clients to retrieve certificates, certificate chains and
associated data, eg. the UTXO</li><li>UTXO are stored in a Merkle Tree and can be retrieved individually along with associated proof. The certificate
signs only the root of the Merkle Tree, thus minimising the amount of data clients have to process to validate
them</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="performance">Performance<a class="hash-link" href="#performance" title="Direct link to heading">​</a></h4><ul><li>At this stage it was not deemed necessary to setup a full blown performance analysis of the nodes</li><li>Basic benchmarks run have shown that a node can produce an aggregate multisignature for 10 M UTXO in 3'45''<ul><li>About half of this execution time is spent querying and retrieving the data from the DB</li></ul></li><li>There has been no attempt so far at scaling the number of nodes but given what we know from the behaviour of the
library, it's pretty clear the limiting factor will be the network protocol</li></ul><h1>Use Cases</h1><ul><li><p>In parallel with PoC development we have been working with Product Dpt on the use cases for Mithril in order to
understand what a path to productisation could look like.</p></li><li><p>The Lightwallet workshop that occured early November was an opportunity to better understand the Lightwallet
requirements for Mithril, eg. enabling fast and trustless bootstrap of wallets</p></li><li><p>We conducted a series of <a href="https://www.jpattonassociates.com/story-mapping/" target="_blank" rel="noopener noreferrer">Story Mapping</a> sessions from November 2021
until early January 2022 in order to delve into some use cases in more details. These sessions were framed in the
context of implementing Mithril for fast bootstrapping of Daedalus.
<img loading="lazy" src="/doc/assets/images/story-mapping-bd60049493462b9e16c11de9d63eacfc.jpg" width="4666" height="3428" class="img_E7b_"></p></li><li><p>We distinguished 3 kind of "mithril nodes":</p><ul><li>The ones that run the signing and certificate issuance protocol, run by SPOs,</li><li>The so-called <em>Mithril Client</em> nodes that are actually full Cardano nodes with the capability to retrieve and
validate certificates,</li><li><em>Peer nodes</em> which are full Cardano nodes storing and providing certificates</li></ul></li><li><p>These sessions allowed us to uncover important aspects of the integration of Mithril in the Daedalus wallet in order
to provide faster "boot" time. Some questions/issues/puzzles that were raised:</p><ul><li>How does the certificate chain is bootstrapped? We'd need to have root certificate signed by genesis keys?</li><li>To speed up the time it takes for a user to retrieve her wallet's balance, she needs to filter the UTXO set by the
addresses of interest, which implies the wallet knows those,</li><li>It's unclear if Mithril will help in reducing the amount of resources needed to run a Daedalus wallet,</li><li>The main (top) story line, <em>A user can retrieve her wallet balance "quickly"</em>, already involves quite a few actors
and will require significant engineering effort and changes to existing network.</li></ul></li><li><p>We have started doing similar exercise in the Lightwallet case but it's very early draft</p></li></ul><h1>Assessment</h1><h2 class="anchor anchorWithStickyNavbar_mojV" id="initial-scope">Initial Scope<a class="hash-link" href="#initial-scope" title="Direct link to heading">​</a></h2><p>Here is a reminder of the goals for this project as was defined in the <em>Business Case</em>.</p><p>Prototype implementation of the Mithril signature scheme; not be usable in production without a moderate amount of
rewriting, documentation, or refactoring. In summary is a solution for fast-bootstrappable wallet implementation.</p><ul class="contains-task-list contains-task-list_tsSF"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <!-- -->Prototype implementation of the primitives, using well-maintained open source efforts where applicable,
implemented in Rust</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <!-- -->Prototype implementation of the concatenation-based protocol from the paper</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <!-- -->Mithril is (for now) exclusively a second layer solution with no new ledger rules to be introduced;</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <!-- -->SPOs will certify the latest UTxO set that the wallet can use at a certain frequency, once per epoch for example;<blockquote><p>Not really done by SPOs but the implemented node does this certification process</p></blockquote></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <!-- -->SPOs will store the latest UTxO set (IPFS or other solutions)<blockquote><p>UTXO set is served from db-sync which already contains it</p></blockquote></li><li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->The wallet will trust the SPO’s certificate to bootstrap from it, downloading the latest UTxO set, and follow the
chain then;</li><li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->The wallet will not be able to do history lookup, just validate new transactions;<blockquote><p>No work has been done with a real wallet but we have evidence that a Mithril-enabled client can be built easily using the same library and validate (chain of) certificates</p></blockquote></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <!-- -->Implement the ATMS cryptographic primitive from our PoS Sidechains paper.</li></ul><p>Build Network and the data storage stacks (node) and integrate the mithril signature scheme:</p><blockquote><p>Precise scope was supposed to be refined after a "feasibility study". We can assume the PoC done by IdyllicVision fills this gap</p></blockquote><h2 class="anchor anchorWithStickyNavbar_mojV" id="risks">Risks<a class="hash-link" href="#risks" title="Direct link to heading">​</a></h2><p>The following risks had been identified and we can check whether or not they have been addressed:</p><ul class="contains-task-list contains-task-list_tsSF"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <!-- -->The technical architecture that will be sufficient for the mithril node is not yet well understood. We need to
create a node that is sufficient for the purpose of this project. We need to learn the lessons of Hydra and use the
most basic structure for the node (impacts delivery timelines and costs).<blockquote><p>We have a better understanding of what it means to build a standalone layer 2 mithril node. From this early experiment, it seems however this might not be the best solution for deployment of Mithril at the Cardano scale</p></blockquote></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <!-- -->It is not known how the fast synchronisation will work with the full node wallets, light wallets, SPOs, exchanges
and other node users. This needs to be assessed by the product leadership to understand the utility of this technology
for Cardano and other platforms<blockquote><p>This has been addressed partially in our User Story Mapping sessions</p></blockquote></li><li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->Need to understand how prototyping output works with our formal methods approach (this is not clear)</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <!-- -->If we at some point want to incorporate the rust library with the cryptographic primitives in Cardano, we will
have to invest a substantial and unknown effort to include another language in our build systems (CI including cross
compilation, and developer builds). Otherwise, it's possible to get the impression that that would be easy, given that
we will get a Haskell API.<blockquote><p>Having deliberately implemented library and node in 2 different languages gave us a good understanding of the kind of integration problems we could run in. Notwithstanding the issue of the skillset needed to maintain polyglot systems, integration has been pretty straightforward. Of course there's a lot to be done to productise this process but it seems reasonable to expect we should be able to use the Mithril library from any C-FFI enabled language, including Haskell, straightforwardly</p></blockquote></li><li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->It is not clear what is going to happen outside of the PoC and this needs to be defined<blockquote><p>This document tries to address that risk in the last section</p></blockquote></li><li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->Scope is not clear with some stakeholders believing that testing of the prototype should include running in a
browser. In this respect it is unclear why we are building a prototype in scala and rust if the end target is running
in a browser “One of the main use-cases for this product is "security of a full node and speed of a light client". I'm
not expecting this version to be very performant, but I do expect it to run on a mobile device (including a phone).”<blockquote><p>This has not been addressed at all. Given the specificity of the Mithril crypto primitives this should be</p></blockquote></li><li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->The expectation of the wallet user of "full node security and lightwallet experience" is definitely not met by
Mirthril according to the product team. Doing some basic research they assert that in bitcoin an SPV wallet would
require 100Mb of storage and 512Mb memory. With the Mithril proposal a "similar" wallet would need a very low amount
of storage(the paper was eluding to about 142Kb) but ~8Gb of memory. As part of this project we need to understand
next steps in order to meet this expectation.<blockquote><p>This has been addressed tangentially as it's also not clear how Mithril would be used from a lightwallet client perspective</p></blockquote></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <!-- -->We need to identify internal resources to sanity check and maintain this. The choice of rust as a language will
cause a problem for us because of resource constraints in this area<blockquote><p>Inigo did a great job at monitoring development of the library and improving it. Rust is a language with a growing community and interest from a lot of developers. From this PoC phase I don't see why we should not be able to either hire rust specialists should we need to, or have internal developers learn enough of rust to be able to maintain and extend the library.</p></blockquote></li><li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->Mithril (fast syncing) use cases include spo’s, consumers, exchanges as well as main chain and side chain. We have
not articulated all of the use cases and need to do so in the prototyping stage for a common understanding of
expectations. This does not mean we will achieve all of them in prototyping but at least we understand what we would
like the technology to do.<blockquote><p>This was partially addressed by the Lightwallet workshop and User story mapping sessions but of course needs to be ramped up</p></blockquote></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <!-- -->We do not know who the customer is for the prototyping output and hence have no idea of who can “accept” or agree
the project has met its goals. This is important if this is to be a success.<blockquote><p>The main goal of this PoC phase was to assess technical feasibility and evaluate possible architecture of the system using an external node.</p></blockquote></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="takeaways">Takeaways<a class="hash-link" href="#takeaways" title="Direct link to heading">​</a></h2><ul><li>The main takeaway of this stage of the project is obviously that the Mithril protocol <em>works</em> and can be used to
provide a chain of certificates on a UTXO Merkle-Tree in such a way that clients can download only a fraction of the
UTXO set confidently and verify it</li><li>Implementing the library in Rust and using it from Go was relatively straightforward. The rust library exposes a plain
C interface which makes it easy to integrate in any language that can talk to C which really means <em>any</em> language (
except Javascript inside a browser)</li><li>Running the Mithril signing protocol requires significant resources (retrieving and storing the UTXO, connecting to
and managing networking with peer nodes, storing and delivering certificates) for which there is currently no
incentive</li><li>We have barely explored the question of the Mithril network. In the current Go node implementation, nodes are
connected using <a href="https://libp2p.io/" target="_blank" rel="noopener noreferrer">libp2p</a> but we have no idea how this would scale nor whether it fits our needs,
which are themselves unclear.<ul><li>The biggest issue we foresee is that Mithril will only ever be useful if the vast majority of SPOs sign and serve
certificates, which means the network of signers has to be mostly the same as the network of block producers.
Recreating another network alongside the existing Cardano network seems a huge hurdle to overcome</li></ul></li><li>The main problem of a pure "Layer 2" (independent) solution for Mithril is that integration with Cardano network layer
might be hard<ul><li>Mithril node needs access to the UTXO set <em>and</em> the stake distribution to provide certificates. This can be
queried from either db-sync or directly from the node using existing protocol.</li></ul></li><li>Preliminary discussion about the Daedalus use case have shown that it's extremely useful to tie the development of
Mithril to concrete usage scenario in order to make sure the built prototype touches on all the thorny points inherent
with such far reaching ideas</li></ul><h1>Next steps</h1><ol><li>Settle on a single concrete goal/use case<ul><li>Having a single goal will help achieve concrete results earlier</li><li>Identify clearly the various Mithril "Users" in the context of this broad use case</li><li>Possible single goals are:<ul><li>Bootstrap Daedalus/full-node based wallet faster</li><li>Bootstrap SPOs/Exchanges full nodes faster</li><li>Enable trustless lightwallet</li></ul></li></ul></li><li>Setup a proper small team with product and engineering to start building solution iteratively</li><li>Explore alternative architectures where data acquisition about the state of the network does not go through db-sync
and which could have lighter footprint<ul><li>Still using a standalone node but using node APIs (ChainSync protocol, Ogmios) to retrieve its state and
maintaining UTXO set in the node</li><li>Tighter integration within the node itself, for example by piggybacking on the network layer. This is predicated
on capabilities to not interfere with other node's functions/components (eg. consensus, ledger)</li></ul></li><li>Designe proper networking solution for connecting Mithril nodes<ul><li>Networking is of course highly dependent on use case</li></ul></li><li>Explore/Provide browser-based solution for Mithril certificates validation<ul><li>We don't need a full-blown Mithril library but JS clients need to be able to validate chain of mithril
certificates inside a browser context</li><li>This is predicated on the actual use case defined in 1.: If we only want to address</li></ul></li><li>Productise separate signing/verification libraries/tools<ul><li>Having usable and well-documented libraries and tools will make it easier to build various clients and higher
level tools on top of it</li></ul></li><li>Work on <a href="/doc/test-lab/test-lab-overview">Mithril Test Lab</a> to build a semi-formal ETE testing solution to validate
the protocol's implementation independently of the technology</li></ol>]]></content:encoded>
        </item>
    </channel>
</rss>