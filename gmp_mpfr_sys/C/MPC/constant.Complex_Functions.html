<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This constant is a place-holder for documentation; do not use it in code."><meta name="keywords" content="rust, rustlang, rust-lang, Complex_Functions"><title>Complex_Functions in gmp_mpfr_sys::C::MPC - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../gmp_mpfr_sys/index.html'><div class='logo-container rust-logo'><img src='data:image&#x2F;svg+xml;base64,
PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCEtLSBDcmVhdGVkIHdpdGggSW5rc2NhcGUgKGh0dHA6Ly93
d3cuaW5rc2NhcGUub3JnLykgLS0+Cjxzdmcgd2lkdGg9IjEyOCIgaGVpZ2h0PSIxMjgiIHZlcnNpb249IjEuMSIgdmlld0JveD0i
MCAwIDMzLjg2NjY2NiAzMy44NjY2NjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6Y2M9Imh0dHA6
Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxu
czpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogPG1ldGFkYXRhPgogIDxyZGY6UkRG
PgogICA8Y2M6V29yayByZGY6YWJvdXQ9IiI+CiAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgIDxk
Yzp0eXBlIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiLz4KICAgIDxkYzp0aXRs
ZS8+CiAgIDwvY2M6V29yaz4KICA8L3JkZjpSREY+CiA8L21ldGFkYXRhPgogPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAtMjYz
LjEzKSI+CiAgPHBhdGggZD0ibTMzLjg2NyAyODAuMDdhMTYuOTMzIDE2LjkzMyAwIDAgMSAtMTYuOTMzIDE2LjkzMyAxNi45MzMg
MTYuOTMzIDAgMCAxIC0xNi45MzMgLTE2LjkzMyAxNi45MzMgMTYuOTMzIDAgMCAxIDE2LjkzMyAtMTYuOTMzIDE2LjkzMyAxNi45
MzMgMCAwIDEgMTYuOTMzIDE2LjkzM3oiIGZpbGw9IiNmZmZmYzAiLz4KICA8ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0
cm9rZS13aWR0aD0iLjI2NDU4cHgiPgogICA8ZyBhcmlhLWxhYmVsPSI2Ij4KICAgIDxwYXRoIGQ9Im0xNC40NzEgMjg0LjA3YzIu
MjAxMyAwIDQuMDM1OC0xLjQ2NzYgNC4wMzU4LTMuOTYyNCAwLTIuNDk0OC0xLjU0MDktMy41OTU1LTMuNTIyMS0zLjU5NTUtMC42
MjM3MSAwLTEuNjE0MyAwLjQwMzU4LTIuMTgzIDEuMTU1NyAwLjEyODQxLTIuMzQ4MSAxLjAwODktMy4xMzY5IDIuMTQ2My0zLjEz
NjkgMC42NjA0IDAgMS4zOTQyIDAuNDAzNTggMS43NjExIDAuODA3MTZsMS42NTEtMS44NzExYy0wLjc3MDQ3LTAuNzcwNDctMS45
ODEyLTEuNDY3Ni0zLjYzMjItMS40Njc2LTIuNDk0OCAwLTQuODA2MiAyLjAxNzktNC44MDYyIDYuMjM3MXMyLjMxMTQgNS44MzM1
IDQuNTQ5NCA1LjgzMzV6bS0wLjA3MzM4LTIuMzQ4MWMtMC41Njg2OCAwLTEuMjY1OC0wLjM4NTI0LTEuNTIyNi0yLjAxNzkgMC4z
NjY4OS0wLjY5NzA5IDAuOTM1NTctMC45OTA2IDEuNDg1OS0wLjk5MDYgMC42NjA0IDAgMS4yODQxIDAuMjc1MTYgMS4yODQxIDEu
Mzk0MiAwIDEuMjI5MS0wLjU4NzAyIDEuNjE0My0xLjI0NzQgMS42MTQzeiIgZmlsbD0iIzAwMTAzMCIgc3Ryb2tlPSJub25lIi8+
CiAgIDwvZz4KICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoMTUuNTE1KSIgYXJpYS1sYWJlbD0iMiI+CiAgICA8cGF0aCBkPSJtOTgu
MDM1IDI2Ny45NWg1LjA0NjF2LTEuMzk5OGgtMS40NDVjLTAuMzM4NjcgMC0wLjgzNTM4IDAuMDQ1Mi0xLjE5NjYgMC4wOTAzIDEu
MTYyOC0xLjIxOTIgMi4yOTE2LTIuNTA2MSAyLjI5MTYtMy43MTQgMC0xLjM3NzItMC45NTk1NS0yLjI4MDQtMi4zNzA3LTIuMjgw
NC0xLjAyNzMgMC0xLjY5MzMgMC4zODM4Mi0yLjQwNDUgMS4xNDAybDAuOTAzMTEgMC44OTE4MmMwLjM2MTI0LTAuMzgzODIgMC43
NTYzNi0wLjczMzc4IDEuMjc1Ni0wLjczMzc4IDAuNjIwODkgMCAxLjAxNiAwLjM4MzgzIDEuMDE2IDEuMDgzNyAwIDEuMDE2LTEu
Mjg2OSAyLjI0NjUtMy4xMTU3IDMuOTczN3oiIGZpbGw9IiMwMDEwMzAiIGZpbGwtb3BhY2l0eT0iLjk3MjU1IiBzdHJva2U9Im5v
bmUiLz4KICAgPC9nPgogICA8ZyB0cmFuc2Zvcm09InJvdGF0ZSgtMTEuMDMzKSIgYXJpYS1sYWJlbD0iOCI+CiAgICA8cGF0aCBk
PSJtLTM4LjkyIDI5MC43NmMxLjI3NDIgMCAyLjEyMzctMC43NDA4MyAyLjEyMzctMS43MDg4IDAtMC44Mzk2Mi0wLjUwMzc3LTEu
MzAzOS0xLjA4NjYtMS42Mjk4di0wLjAzOTVjMC40MDQ5OS0wLjI5NjMzIDAuODM5NjEtMC44MTk4NSAwLjgzOTYxLTEuNDQyMiAw
LTEuMDE3NC0wLjcyMTA4LTEuNjk5LTEuODQ3MS0xLjY5OS0xLjA4NjYgMC0xLjg5NjUgMC42NTE5My0xLjg5NjUgMS42NjkzIDAg
MC42NjE4MSAwLjM4NTIzIDEuMTI2MSAwLjg2OTI0IDEuNDcxOHYwLjAzOTVjLTAuNTkyNjcgMC4zMTYwOS0xLjEzNTkgMC44Mjk3
NC0xLjEzNTkgMS42MTAxIDAgMS4wMTc0IDAuOTA4NzYgMS43Mjg2IDIuMTMzNiAxLjcyODZ6bTAuNDE0ODctMy42NjQ2Yy0wLjcw
MTMyLTAuMjc2NTgtMS4yNjQ0LTAuNTUzMTYtMS4yNjQ0LTEuMTg1MyAwLTAuNTQzMjggMC4zNzUzNi0wLjg1OTM2IDAuODU5Mzct
MC44NTkzNiAwLjU4Mjc5IDAgMC45Mjg1MSAwLjQwNDk4IDAuOTI4NTEgMC45NTgxNCAwIDAuMzk1MTEtMC4xODc2OCAwLjc1MDcx
LTAuNTIzNTIgMS4wODY2em0tMC4zOTUxMSAyLjg1NDdjLTAuNjQyMDYgMC0xLjE1NTctMC40MTQ4Ni0xLjE1NTctMS4wMzcyIDAt
MC40ODQwMSAwLjI4NjQ2LTAuODg5IDAuNjgxNTctMS4xNzU1IDAuODQ5NDkgMC4zNDU3MiAxLjUxMTMgMC41OTI2NyAxLjUxMTMg
MS4yNzQyIDAgMC41ODI3OS0wLjQzNDYyIDAuOTM4MzktMS4wMzcyIDAuOTM4Mzl6IiBmaWxsPSIjMDAxMDMwIiBmaWxsLW9wYWNp
dHk9Ii45NDExOCIgc3Ryb2tlPSJub25lIi8+CiAgIDwvZz4KICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoNi41MDA4KSIgYXJpYS1s
YWJlbD0iMyI+CiAgICA8cGF0aCBkPSJtMzkuMzAyIDI4My42NGMxLjAzMjkgMCAxLjg4ODEtMC41NzU3MyAxLjg4ODEtMS41NTc5
IDAtMC43MTEyLTAuNDgyNi0xLjE2ODQtMS4xMTc2LTEuMzM3N3YtMC4wMzM5YzAuNTg0Mi0wLjIyODYgMC45Mzk4LTAuNjM1IDAu
OTM5OC0xLjIzNjEgMC0wLjkxNDQtMC43MTEyLTEuNDIyNC0xLjc0NDEtMS40MjI0LTAuNjQzNDcgMC0xLjE1OTkgMC4yNzA5My0x
LjYxNzEgMC42NzczM2wwLjQ5OTUzIDAuNjAxMTRjMC4zMzAyLTAuMzA0OCAwLjY2MDQtMC41MDggMS4wODM3LTAuNTA4IDAuNDkx
MDcgMCAwLjc5NTg3IDAuMjcwOTMgMC43OTU4NyAwLjcxOTY3IDAgMC40OTk1My0wLjM0NzEzIDAuODYzNi0xLjQwNTUgMC44NjM2
djAuNzExMmMxLjIyNzcgMCAxLjU4MzMgMC4zNTU2IDEuNTgzMyAwLjkxNDQgMCAwLjUwOC0wLjQwNjQgMC44MTI4LTAuOTkwNiAw
LjgxMjgtMC41NDE4NyAwLTAuOTU2NzMtMC4yNjI0Ny0xLjI3ODUtMC41OTI2N2wtMC40NjU2NyAwLjYyNjUzYzAuMzgxIDAuNDIz
MzQgMC45NTY3MyAwLjc2MiAxLjgyODggMC43NjJ6IiBmaWxsPSIjMDAxMDMwIiBmaWxsLW9wYWNpdHk9Ii44Nzg0MyIgc3Ryb2tl
PSJub25lIi8+CiAgIDwvZz4KICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoOC4zNTYpIiBhcmlhLWxhYmVsPSIxIj4KICAgIDxwYXRo
IGQ9Im00Ni40MDUgMjY4LjloMy4yNDI3di0wLjc5NTg3aC0xLjA1ODN2LTQuNTg4OWgtMC43MjgxM2MtMC4zMzg2NyAwLjIwMzIt
MC43MTEyIDAuMzM4NjYtMS4yNDQ2IDAuNDQwMjZ2MC42MDk2aDAuOTkwNnYzLjUzOTFoLTEuMjAyM3oiIGZpbGw9IiMwMDEwMzAi
IGZpbGwtb3BhY2l0eT0iLjc1Mjk0IiBzdHJva2U9Im5vbmUiLz4KICAgPC9nPgogICA8ZyB0cmFuc2Zvcm09InJvdGF0ZSgxMi44
NjEpIiBhcmlhLWxhYmVsPSI4Ij4KICAgIDxwYXRoIGQ9Im04NS4wMzYgMjYxLjYzYzEuMDkyMiAwIDEuODIwMy0wLjYzNSAxLjgy
MDMtMS40NjQ3IDAtMC43MTk2Ny0wLjQzMTgtMS4xMTc2LTAuOTMxMzMtMS4zOTd2LTAuMDMzOWMwLjM0NzEzLTAuMjU0IDAuNzE5
NjctMC43MDI3MyAwLjcxOTY3LTEuMjM2MSAwLTAuODcyMDctMC42MTgwNy0xLjQ1NjMtMS41ODMzLTEuNDU2My0wLjkzMTMzIDAt
MS42MjU2IDAuNTU4OC0xLjYyNTYgMS40MzA5IDAgMC41NjcyNiAwLjMzMDIgMC45NjUyIDAuNzQ1MDcgMS4yNjE1djAuMDMzOWMt
MC41MDggMC4yNzA5My0wLjk3MzY3IDAuNzExMi0wLjk3MzY3IDEuMzgwMSAwIDAuODcyMDcgMC43Nzg5MyAxLjQ4MTcgMS44Mjg4
IDEuNDgxN3ptMC4zNTU2LTMuMTQxMWMtMC42MDExMy0wLjIzNzA3LTEuMDgzNy0wLjQ3NDE0LTEuMDgzNy0xLjAxNiAwLTAuNDY1
NjcgMC4zMjE3My0wLjczNjYgMC43MzY2LTAuNzM2NiAwLjQ5OTUzIDAgMC43OTU4NyAwLjM0NzEzIDAuNzk1ODcgMC44MjEyNiAw
IDAuMzM4NjctMC4xNjA4NyAwLjY0MzQ3LTAuNDQ4NzMgMC45MzEzNHptLTAuMzM4NjcgMi40NDY5Yy0wLjU1MDMzIDAtMC45OTA2
LTAuMzU1Ni0wLjk5MDYtMC44ODkgMC0wLjQxNDg2IDAuMjQ1NTMtMC43NjIgMC41ODQyLTEuMDA3NSAwLjcyODEzIDAuMjk2MzMg
MS4yOTU0IDAuNTA4IDEuMjk1NCAxLjA5MjIgMCAwLjQ5OTUzLTAuMzcyNTMgMC44MDQzMy0wLjg4OSAwLjgwNDMzeiIgZmlsbD0i
IzAwMTAzMCIgZmlsbC1vcGFjaXR5PSIuNjI3NDUiIHN0cm9rZT0ibm9uZSIvPgogICA8L2c+CiAgIDxnIHRyYW5zZm9ybT0icm90
YXRlKDQuMzA5OSkiIGFyaWEtbGFiZWw9IjUiPgogICAgPHBhdGggZD0ibTQ2LjM0MSAyODkuNDljMC45OTA2IDAgMS44OTY1LTAu
Njc3MzQgMS44OTY1LTEuODU0MiAwLTEuMTU5OS0wLjc3MDQ3LTEuNjg0OS0xLjY5MzMtMS42ODQ5LTAuMjc5NCAwLTAuNDgyNiAw
LjA2NzctMC43MTEyIDAuMTc3OGwwLjExMDA3LTEuMzAzOWgyLjAzMnYtMC44MjEyN2gtMi44Nzg3bC0wLjE2MDg3IDIuNjU4NSAw
LjQ2NTY3IDAuMjk2MzNjMC4zMjE3My0wLjIxMTY3IDAuNTE2NDctMC4zMDQ4IDAuODYzNi0wLjMwNDggMC41OTI2NyAwIDAuOTkw
NiAwLjM2NDA3IDAuOTkwNiAxLjAwNzUgMCAwLjY1MTk0LTAuNDQwMjcgMS4wMzI5LTEuMDQxNCAxLjAzMjktMC41NDE4NyAwLTAu
OTM5OC0wLjI3MDk0LTEuMjYxNS0wLjU3NTc0bC0wLjQ0ODczIDAuNjI2NTRjMC4zOTc5MyAwLjM5NzkzIDAuOTY1MiAwLjc0NTA3
IDEuODM3MyAwLjc0NTA3eiIgZmlsbD0iIzAwMTAzMCIgZmlsbC1vcGFjaXR5PSIuNTAxOTYiIHN0cm9rZT0ibm9uZSIvPgogICA8
L2c+CiAgPC9nPgogIDxnIGZpbGw9IiMwMDEwMzAiIGZpbGwtb3BhY2l0eT0iLjM3NjQ3IiBzdHJva2U9IiMwMDAiIHN0cm9rZS13
aWR0aD0iLjI2NDU4cHgiIGFyaWEtbGFiZWw9IjMiPgogICA8cGF0aCBkPSJtOS44ODU5IDI5My40NmMxLjAzMjkgMCAxLjg4ODEt
MC41NzU3NCAxLjg4ODEtMS41NTc5IDAtMC43MTEyLTAuNDgyNi0xLjE2ODQtMS4xMTc2LTEuMzM3N3YtMC4wMzM5YzAuNTg0Mi0w
LjIyODYgMC45Mzk4LTAuNjM1IDAuOTM5OC0xLjIzNjEgMC0wLjkxNDQtMC43MTEyLTEuNDIyNC0xLjc0NDEtMS40MjI0LTAuNjQz
NDcgMC0xLjE1OTkgMC4yNzA5My0xLjYxNzEgMC42NzczM2wwLjQ5OTUzIDAuNjAxMTNjMC4zMzAyLTAuMzA0OCAwLjY2MDQtMC41
MDggMS4wODM3LTAuNTA4IDAuNDkxMDcgMCAwLjc5NTg3IDAuMjcwOTQgMC43OTU4NyAwLjcxOTY3IDAgMC40OTk1My0wLjM0NzEz
IDAuODYzNi0xLjQwNTUgMC44NjM2djAuNzExMmMxLjIyNzcgMCAxLjU4MzMgMC4zNTU2IDEuNTgzMyAwLjkxNDQgMCAwLjUwOC0w
LjQwNjQgMC44MTI4LTAuOTkwNiAwLjgxMjgtMC41NDE4NyAwLTAuOTU2NzMtMC4yNjI0Ny0xLjI3ODUtMC41OTI2N2wtMC40NjU2
NyAwLjYyNjU0YzAuMzgxIDAuNDIzMzMgMC45NTY3MyAwLjc2MiAxLjgyODggMC43NjJ6IiBmaWxsPSIjMDAxMDMwIiBmaWxsLW9w
YWNpdHk9Ii4zNzY0NyIgc3Ryb2tlPSJub25lIi8+CiAgPC9nPgogIDxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMCIgc3Ryb2tl
LXdpZHRoPSIuMjY0NThweCI+CiAgIDxnIHRyYW5zZm9ybT0icm90YXRlKC0xMS4zNTIpIiBhcmlhLWxhYmVsPSIwIj4KICAgIDxw
YXRoIGQ9Im0tNTEuNDcxIDI3Ni4xN2MxLjExNzYgMCAxLjgyODgtMC45OTkwNyAxLjgyODgtMi44MTk0IDAtMS44MTE5LTAuNzEx
Mi0yLjc2ODYtMS44Mjg4LTIuNzY4NnMtMS44Mjg4IDAuOTQ4MjctMS44Mjg4IDIuNzY4NiAwLjcxMTIgMi44MTk0IDEuODI4OCAy
LjgxOTR6bTAtMC43NjJjLTAuNTE2NDcgMC0wLjg5NzQ3LTAuNTMzNC0wLjg5NzQ3LTIuMDU3NHMwLjM4MS0yLjAwNjYgMC44OTc0
Ny0yLjAwNjZjMC41MjQ5MyAwIDAuODk3NDcgMC40ODI2IDAuODk3NDcgMi4wMDY2cy0wLjM3MjUzIDIuMDU3NC0wLjg5NzQ3IDIu
MDU3NHoiIGZpbGw9IiMwMDEwMzAiIGZpbGwtb3BhY2l0eT0iLjI1MDk4IiBzdHJva2U9Im5vbmUiLz4KICAgPC9nPgogICA8ZyB0
cmFuc2Zvcm09InJvdGF0ZSgyMi41MDYpIiBhcmlhLWxhYmVsPSI3Ij4KICAgIDxwYXRoIGQ9Im0xMTguMjEgMjQzLjA4aDAuOTkw
NmMwLjA5MzEtMi4wOTk3IDAuMzEzMjctMy4yMjU4IDEuNTc0OC00Ljc5MjF2LTAuNTkyNjdoLTMuNjE1M3YwLjgyMTI3aDIuNTQ4
NWMtMS4wNDE0IDEuNDQ3OC0xLjQwNTUgMi42NTAxLTEuNDk4NiA0LjU2MzV6IiBmaWxsPSIjMDAxMDMwIiBmaWxsLW9wYWNpdHk9
Ii4xMjU0OSIgc3Ryb2tlPSJub25lIi8+CiAgIDwvZz4KICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoLTkuNzI3MykiIGFyaWEtbGFi
ZWw9IjEiPgogICAgPHBhdGggZD0ibS0xOC4yOTkgMjgyLjc5aDMuMjQyN3YtMC43OTU4N2gtMS4wNTgzdi00LjU4ODloLTAuNzI4
MTNjLTAuMzM4NjcgMC4yMDMyLTAuNzExMiAwLjMzODY3LTEuMjQ0NiAwLjQ0MDI3djAuNjA5NmgwLjk5MDZ2My41MzkxaC0xLjIw
MjN6IiBmaWxsPSIjMDAxMDMwIiBmaWxsLW9wYWNpdHk9Ii4wNjI3NDUiIHN0cm9rZT0ibm9uZSIvPgogICA8L2c+CiAgPC9nPgog
IDxnIGZpbGw9IiMyNDEwMzAiIGFyaWEtbGFiZWw9Ii4iPgogICA8cGF0aCBkPSJtMjAuOTIgMjgzLjk4YzAuNjU0NzYgMCAxLjEy
ODktMC41MTkyOSAxLjEyODktMS4xNzQgMC0wLjY1NDc2LTAuNDc0MTMtMS4xNzQtMS4xMjg5LTEuMTc0LTAuNjU0NzYgMC0xLjEy
ODkgMC41MTkyOS0xLjEyODkgMS4xNzQgMCAwLjY1NDc1IDAuNDc0MTMgMS4xNzQgMS4xMjg5IDEuMTc0eiIgZmlsbD0iIzAwMTAz
MCIvPgogIDwvZz4KIDwvZz4KPC9zdmc+Cg==
' alt='logo'></div></a><div class="sidebar-elems"><h2 class="location">Other items in<br><a href="../../index.html">gmp_mpfr_sys</a>::<wbr><a href="../index.html">C</a>::<wbr><a href="index.html">MPC</a></h2><div id="sidebar-vars" data-name="Complex_Functions" data-ty="constant" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Constant <a href="../../index.html">gmp_mpfr_sys</a>::<wbr><a href="../index.html">C</a>::<wbr><a href="index.html">MPC</a>::<wbr><a class="constant" href="#">Complex_Functions</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/gmp_mpfr_sys/C.rs.html#242" title="goto source code">[src]</a></span></h1><div class="docblock item-decl"><pre class="rust const"><code>pub const Complex_Functions: <a class="primitive" href="https://doc.rust-lang.org/1.58.0/core/primitive.unit.html">()</a>;</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This constant is a place-holder for documentation; do not use it in code.</p>
<hr />
<div><span id="start"></span></div>
<span id="Complex-Functions"></span><div class="header">
<p>
Next: <a href="constant.References.html#start" accesskey="n" rel="next">References</a>, Previous: <a href="constant.GNU_MPC_Basics.html#start" accesskey="p" rel="prev">GNU MPC Basics</a>, Up: <a href="index.html#start" accesskey="u" rel="up">Top</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Complex-Functions-1"></span><h2 class="chapter">5 Complex Functions</h2>
<span id="index-Complex-functions"></span>
<p>The complex functions expect arguments of type <code>mpc_t</code>.
</p>
<p>The GNU MPC floating-point functions have an interface that is similar to the
GNU MP
integer functions.  The function prefix for operations on complex numbers is
<code>mpc_</code>.
</p>
<span id="index-User_002ddefined-precision"></span>
<p>The precision of a computation is defined as follows: Compute the requested
operation exactly (with &ldquo;infinite precision&rdquo;), and round the result to
the destination variable precision with the given rounding mode.
</p>
<p>The GNU MPC complex functions are intended to be a smooth extension
of the IEEE P754 arithmetic. The results obtained on one
computer should not differ from the results obtained on a computer with a
different word size.
</p>
<table class="menu" style="margin: 0; width: auto; padding: 0; border: 0;" border="0" cellspacing="0">
<tr><td style="padding: 0; border: 0;"  align="left" valign="top">&bull; <a href="#Initializing-Complex-Numbers" accesskey="1">Initializing Complex Numbers</a></td><td style="padding: 0; border: 0;" >&nbsp;&nbsp;</td><td style="padding: 0; border: 0;"  align="left" valign="top">
</td></tr>
<tr><td style="padding: 0; border: 0;"  align="left" valign="top">&bull; <a href="#Assigning-Complex-Numbers" accesskey="2">Assigning Complex Numbers</a></td><td style="padding: 0; border: 0;" >&nbsp;&nbsp;</td><td style="padding: 0; border: 0;"  align="left" valign="top">
</td></tr>
<tr><td style="padding: 0; border: 0;"  align="left" valign="top">&bull; <a href="#Converting-Complex-Numbers" accesskey="3">Converting Complex Numbers</a></td><td style="padding: 0; border: 0;" >&nbsp;&nbsp;</td><td style="padding: 0; border: 0;"  align="left" valign="top">
</td></tr>
<tr><td style="padding: 0; border: 0;"  align="left" valign="top">&bull; <a href="#String-and-Stream-Input-and-Output" accesskey="4">String and Stream Input and Output</a></td><td style="padding: 0; border: 0;" >&nbsp;&nbsp;</td><td style="padding: 0; border: 0;"  align="left" valign="top">
</td></tr>
<tr><td style="padding: 0; border: 0;"  align="left" valign="top">&bull; <a href="#Complex-Comparison" accesskey="5">Complex Comparison</a></td><td style="padding: 0; border: 0;" >&nbsp;&nbsp;</td><td style="padding: 0; border: 0;"  align="left" valign="top">
</td></tr>
<tr><td style="padding: 0; border: 0;"  align="left" valign="top">&bull; <a href="#Projection-_0026-Decomposing" accesskey="6">Projection &amp; Decomposing</a></td><td style="padding: 0; border: 0;" >&nbsp;&nbsp;</td><td style="padding: 0; border: 0;"  align="left" valign="top">
</td></tr>
<tr><td style="padding: 0; border: 0;"  align="left" valign="top">&bull; <a href="#Basic-Arithmetic" accesskey="7">Basic Arithmetic</a></td><td style="padding: 0; border: 0;" >&nbsp;&nbsp;</td><td style="padding: 0; border: 0;"  align="left" valign="top">
</td></tr>
<tr><td style="padding: 0; border: 0;"  align="left" valign="top">&bull; <a href="#Power-Functions-and-Logarithm" accesskey="8">Power Functions and Logarithm</a></td><td style="padding: 0; border: 0;" >&nbsp;&nbsp;</td><td style="padding: 0; border: 0;"  align="left" valign="top">
</td></tr>
<tr><td style="padding: 0; border: 0;"  align="left" valign="top">&bull; <a href="#Trigonometric-Functions" accesskey="9">Trigonometric Functions</a></td><td style="padding: 0; border: 0;" >&nbsp;&nbsp;</td><td style="padding: 0; border: 0;"  align="left" valign="top">
</td></tr>
<tr><td style="padding: 0; border: 0;"  align="left" valign="top">&bull; <a href="#Miscellaneous-Complex-Functions">Miscellaneous Complex Functions</a></td><td style="padding: 0; border: 0;" >&nbsp;&nbsp;</td><td style="padding: 0; border: 0;"  align="left" valign="top">
</td></tr>
<tr><td style="padding: 0; border: 0;"  align="left" valign="top">&bull; <a href="#Advanced-Functions">Advanced Functions</a></td><td style="padding: 0; border: 0;" >&nbsp;&nbsp;</td><td style="padding: 0; border: 0;"  align="left" valign="top">
</td></tr>
<tr><td style="padding: 0; border: 0;"  align="left" valign="top">&bull; <a href="#Internals">Internals</a></td><td style="padding: 0; border: 0;" >&nbsp;&nbsp;</td><td style="padding: 0; border: 0;"  align="left" valign="top">
</td></tr>
</table>
<hr>
<span id="Initializing-Complex-Numbers"></span><div class="header">
<p>
Next: <a href="#Assigning-Complex-Numbers" accesskey="n" rel="next">Assigning Complex Numbers</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Initialization-Functions"></span><h3 class="section">5.1 Initialization Functions</h3>
<p>An <code>mpc_t</code> object must be initialised before storing the first value in
it.  The functions <code>mpc_init2</code> and <code>mpc_init3</code>
are used for that purpose.
</p>
<dl>
<dt id="index-mpc_005finit2">Function: <em>void</em> <strong>mpc_init2</strong> <em>(mpc_t <var>z</var>, mpfr_prec_t <var>prec</var>)</em></dt>
<dd><p>Initialise <var>z</var> to precision <var>prec</var> bits
and set its real and imaginary parts to NaN.
Normally, a variable should be initialised once only
or at least be cleared, using <code>mpc_clear</code>, between initializations.
</p></dd></dl>
<dl>
<dt id="index-mpc_005finit3">Function: <em>void</em> <strong>mpc_init3</strong> <em>(mpc_t <var>z</var>, mpfr_prec_t <var>prec_r</var>, mpfr_prec_t <var>prec_i</var>)</em></dt>
<dd><p>Initialise <var>z</var> with the precision of its real part being
<var>prec_r</var> bits and the precision of its imaginary part being
<var>prec_i</var> bits, and set the real and imaginary parts to NaN.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fclear">Function: <em>void</em> <strong>mpc_clear</strong> <em>(mpc_t <var>z</var>)</em></dt>
<dd><p>Free the space occupied by <var>z</var>.  Make sure to call this function for all
<code>mpc_t</code> variables when you are done with them.
</p></dd></dl>
<p>Here is an example on how to initialise complex variables:
</p><div class="example">
<pre class="example">{
  mpc_t x, y;
  mpc_init2 (x, 256);		/* precision <em>exactly</em> 256 bits */
  mpc_init3 (y, 100, 50);	/* 100/50 bits for the real/imaginary part */
  &hellip;
  mpc_clear (x);
  mpc_clear (y);
}
</pre></div>
<p>The following function is useful for changing the precision during a
calculation.  A typical use would be for adjusting the precision gradually in
iterative algorithms like Newton-Raphson, making the computation precision
closely match the actual accurate part of the numbers.
</p>
<dl>
<dt id="index-mpc_005fset_005fprec">Function: <em>void</em> <strong>mpc_set_prec</strong> <em>(mpc_t <var>x</var>, mpfr_prec_t <var>prec</var>)</em></dt>
<dd><p>Reset the precision of <var>x</var> to be <strong>exactly</strong> <var>prec</var> bits,
and set its real/imaginary parts to NaN.
The previous value stored in <var>x</var> is lost. It is equivalent to
a call to <code>mpc_clear(x)</code> followed by a call to
<code>mpc_init2(x, prec)</code>, but more efficient as no allocation is done in
case the current allocated space for the mantissa of <var>x</var> is sufficient.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fget_005fprec">Function: <em>mpfr_prec_t</em> <strong>mpc_get_prec</strong> <em>(const mpc_t <var>x</var>)</em></dt>
<dd><p>If the real and imaginary part of <var>x</var> have the same precision, it is returned,
otherwise, 0 is returned.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fget_005fprec2">Function: <em>void</em> <strong>mpc_get_prec2</strong> <em>(mpfr_prec_t* <var>pr</var>, mpfr_prec_t* <var>pi</var>, const mpc_t <var>x</var>)</em></dt>
<dd><p>Returns the precision of the real part of <var>x</var> via <var>pr</var> and of its imaginary part
via <var>pi</var>.
</p></dd></dl>
<hr>
<span id="Assigning-Complex-Numbers"></span><div class="header">
<p>
Next: <a href="#Converting-Complex-Numbers" accesskey="n" rel="next">Converting Complex Numbers</a>, Previous: <a href="#Initializing-Complex-Numbers" accesskey="p" rel="prev">Initializing Complex Numbers</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Assignment-Functions"></span><h3 class="section">5.2 Assignment Functions</h3>
<span id="index-Complex-assignment-functions"></span>
<p>These functions assign new values to already initialised complex numbers
(see <a href="#Initializing-Complex-Numbers">Initializing Complex Numbers</a>).
When using any functions with <code>intmax_t</code> or <code>uintmax_t</code>
parameters, you must include
<code>&lt;stdint.h&gt;</code> or <code>&lt;inttypes.h&gt;</code> <em>before</em> <samp>mpc.h</samp>, to allow
<samp>mpc.h</samp> to define prototypes for these functions.
Similarly, functions with parameters of type <code>complex</code> or
<code>long complex</code> are defined only if <code>&lt;complex.h&gt;</code> is included
<em>before</em> <samp>mpc.h</samp>.
If you need assignment functions that are not in the current API, you can
define them using the <code>MPC_SET_X_Y</code> macro (see <a href="#Advanced-Functions">Advanced Functions</a>).
</p>
<dl>
<dt id="index-mpc_005fset">Function: <em>int</em> <strong>mpc_set</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set the value of <var>rop</var> from <var>op</var>, rounded to the precision of <var>rop</var>
with the given rounding mode <var>rnd</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fset_005fui">Function: <em>int</em> <strong>mpc_set_ui</strong> <em>(mpc_t <var>rop</var>, unsigned long int <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fsi">Function: <em>int</em> <strong>mpc_set_si</strong> <em>(mpc_t <var>rop</var>, long int <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fuj">Function: <em>int</em> <strong>mpc_set_uj</strong> <em>(mpc_t <var>rop</var>, uintmax_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fsj">Function: <em>int</em> <strong>mpc_set_sj</strong> <em>(mpc_t <var>rop</var>, intmax_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fd">Function: <em>int</em> <strong>mpc_set_d</strong> <em>(mpc_t <var>rop</var>, double <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fld">Function: <em>int</em> <strong>mpc_set_ld</strong> <em>(mpc_t <var>rop</var>, long double <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fdc">Function: <em>int</em> <strong>mpc_set_dc</strong> <em>(mpc_t <var>rop</var>, double _Complex <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fldc">Function: <em>int</em> <strong>mpc_set_ldc</strong> <em>(mpc_t <var>rop</var>, long double _Complex <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fz">Function: <em>int</em> <strong>mpc_set_z</strong> <em>(mpc_t <var>rop</var>, const mpz_t <var>op</var> mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fq">Function: <em>int</em> <strong>mpc_set_q</strong> <em>(mpc_t <var>rop</var>, const mpq_t <var>op</var> mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005ff">Function: <em>int</em> <strong>mpc_set_f</strong> <em>(mpc_t <var>rop</var>, const mpf_t <var>op</var> mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005ffr">Function: <em>int</em> <strong>mpc_set_fr</strong> <em>(mpc_t <var>rop</var>, const mpfr_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set the value of <var>rop</var> from <var>op</var>, rounded to the precision of
<var>rop</var> with the given rounding mode <var>rnd</var>.
The argument <var>op</var> is interpreted as real, so the imaginary part of
<var>rop</var> is set to zero with a positive sign.
Please note that even a <code>long int</code> may have to be rounded, if the
destination precision is less than the machine word width.
For <code>mpc_set_d</code>, be careful that the input number <var>op</var> may not be
exactly representable as a double-precision number (this happens for 0.1 for
instance), in which case it is first rounded by the C compiler to a
double-precision number, and then only to a complex number.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fset_005fui_005fui">Function: <em>int</em> <strong>mpc_set_ui_ui</strong> <em>(mpc_t <var>rop</var>, unsigned long int <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fsi_005fsi">Function: <em>int</em> <strong>mpc_set_si_si</strong> <em>(mpc_t <var>rop</var>, long int <var>op1</var>, long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fuj_005fuj">Function: <em>int</em> <strong>mpc_set_uj_uj</strong> <em>(mpc_t <var>rop</var>, uintmax_t <var>op1</var>, uintmax_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fsj_005fsj">Function: <em>int</em> <strong>mpc_set_sj_sj</strong> <em>(mpc_t <var>rop</var>, intmax_t <var>op1</var>, intmax_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fd_005fd">Function: <em>int</em> <strong>mpc_set_d_d</strong> <em>(mpc_t <var>rop</var>, double <var>op1</var>, double <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fld_005fld">Function: <em>int</em> <strong>mpc_set_ld_ld</strong> <em>(mpc_t <var>rop</var>, long double <var>op1</var>, long double <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fz_005fz">Function: <em>int</em> <strong>mpc_set_z_z</strong> <em>(mpc_t <var>rop</var>, const mpz_t <var>op1</var>, const mpz_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005fq_005fq">Function: <em>int</em> <strong>mpc_set_q_q</strong> <em>(mpc_t <var>rop</var>, const mpq_t <var>op1</var>, const mpq_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005ff_005ff">Function: <em>int</em> <strong>mpc_set_f_f</strong> <em>(mpc_t <var>rop</var>, const mpf_t <var>op1</var>, const mpf_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fset_005ffr_005ffr">Function: <em>int</em> <strong>mpc_set_fr_fr</strong> <em>(mpc_t <var>rop</var>, const mpfr_t <var>op1</var>, const mpfr_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set the real part of <var>rop</var> from <var>op1</var>, and its imaginary part from
<var>op2</var>, according to the rounding mode <var>rnd</var>.
</p>
<p>Beware that the behaviour of <code>mpc_set_fr_fr</code> is undefined if <var>op1</var>
or <var>op2</var> is a pointer to the real or imaginary part of <var>rop</var>.
To exchange the real and the imaginary part of a complex number, either use
<code>mpfr_swap (mpc_realref (rop), mpc_imagref (rop))</code>, which also exchanges
the precisions of the two parts; or use a temporary variable.
</p></dd></dl>
<p>For functions assigning complex variables from strings or input streams,
see <a href="#String-and-Stream-Input-and-Output">String and Stream Input and Output</a>.
</p>
<dl>
<dt id="index-mpc_005fset_005fnan">Function: <em>void</em> <strong>mpc_set_nan</strong> <em>(mpc_t <var>rop</var>)</em></dt>
<dd><p>Set <var>rop</var> to Nan+i*NaN.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fswap">Function: <em>void</em> <strong>mpc_swap</strong> <em>(mpc_t <var>op1</var>, mpc_t <var>op2</var>)</em></dt>
<dd><p>Swap the values of <var>op1</var> and <var>op2</var> efficiently. Warning: The
precisions are exchanged, too; in case these are different,
<code>mpc_swap</code> is thus not equivalent to three <code>mpc_set</code> calls using a
third auxiliary variable.
</p></dd></dl>
<hr>
<span id="Converting-Complex-Numbers"></span><div class="header">
<p>
Next: <a href="#String-and-Stream-Input-and-Output" accesskey="n" rel="next">String and Stream Input and Output</a>, Previous: <a href="#Assigning-Complex-Numbers" accesskey="p" rel="prev">Assigning Complex Numbers</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Conversion-Functions"></span><h3 class="section">5.3 Conversion Functions</h3>
<span id="index-Conversion-functions"></span>
<p>The following functions are available only if <code>&lt;complex.h&gt;</code>
is included <em>before</em> <samp>mpc.h</samp>.
</p>
<dl>
<dt id="index-_005fComplex">Function: <em>double</em> <strong>_Complex</strong> <em>mpc_get_dc (const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fget_005fldc">Function: <em>long double _Complex</em> <strong>mpc_get_ldc</strong> <em>(mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Convert <var>op</var> to a C complex number, using the rounding mode <var>rnd</var>.
</p></dd></dl>
<p>For functions converting complex variables to strings or stream output,
see <a href="#String-and-Stream-Input-and-Output">String and Stream Input and Output</a>.
</p>
<hr>
<span id="String-and-Stream-Input-and-Output"></span><div class="header">
<p>
Next: <a href="#Complex-Comparison" accesskey="n" rel="next">Complex Comparison</a>, Previous: <a href="#Converting-Complex-Numbers" accesskey="p" rel="prev">Converting Complex Numbers</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="String-and-Stream-Input-and-Output-1"></span><h3 class="section">5.4 String and Stream Input and Output</h3>
<span id="index-String-and-stream-input-and-output"></span>
<dl>
<dt id="index-mpc_005fstrtoc">Function: <em>int</em> <strong>mpc_strtoc</strong> <em>(mpc_t <var>rop</var>, const char *<var>nptr</var>, char **<var>endptr</var>, int <var>base</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Read a complex number from a string <var>nptr</var> in base <var>base</var>, rounded to
the precision of <var>rop</var> with the given rounding mode <var>rnd</var>.
The <var>base</var> must be either 0 or a number from 2 to 36 (otherwise the
behaviour is undefined).
If <var>nptr</var> starts with valid data, the result is stored in <var>rop</var>,
the usual inexact value is returned (see <a href="constant.GNU_MPC_Basics.html#return_002dvalue">Return
Value</a>) and, if <var>endptr</var> is not the null pointer,
<var>*endptr</var> points to the character just after the valid data.
Otherwise, <var>rop</var> is set to <code>NaN + i * NaN</code>, -1 is returned and,
if <var>endptr</var> is not the null pointer,
the value of <var>nptr</var> is stored in the location referenced by
<var>endptr</var>.
</p>
<p>The expected form of a complex number string is either a real number (an
optional leading whitespace, an optional sign followed by a floating-point
number), or a pair of real numbers in parentheses separated by whitespace. If
a real number is read, the missing imaginary part is set to +0.
The form of a floating-point number depends on the base and is described
in the documentation of <code>mpfr_strtofr</code>
in the GNU MPFR manual.
For instance, <code>&quot;3.1415926&quot;</code>, <code>&quot;(1.25e+7 +.17)&quot;</code>, <code>&quot;(@nan@
2)&quot;</code> and <code>&quot;(-0 -7)&quot;</code> are valid strings for <var>base</var> = 10.
If <var>base</var> = 0, then a prefix may be used to indicate the base in which the
floating-point number is written. Use prefix &rsquo;0b&rsquo; for binary numbers, prefix
&rsquo;0x&rsquo; for hexadecimal numbers, and no prefix for decimal numbers.
The real and imaginary part may then be written in different bases.
For instance, <code>&quot;(1.024e+3 +2.05e+3)&quot;</code> and <code>&quot;(0b1p+10 +0x802)&quot;</code> are
valid strings for <code>base</code>=0 and represent the same value.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fset_005fstr">Function: <em>int</em> <strong>mpc_set_str</strong> <em>(mpc_t <var>rop</var>, const char *<var>s</var>, int <var>base</var>, mpc_rnd_t rnd)</em></dt>
<dd><p>Set <var>rop</var> to the value of the string <var>s</var> in base <var>base</var>, rounded
to the precision of <var>rop</var> with the given rounding mode <var>rnd</var>.
See the documentation of <code>mpc_strtoc</code> for a detailed description of the
valid string formats.
Contrarily to <code>mpc_strtoc</code>, <code>mpc_set_str</code> requires the <em>whole</em>
string to represent a valid complex number (potentially followed by
additional white space).
This function returns the usual inexact value (see <a href="constant.GNU_MPC_Basics.html#return_002dvalue">Return
Value</a>) if the entire string up to the final null character is a valid number
in base <var>base</var>; otherwise it returns -1, and <var>rop</var> is set to
NaN+i*NaN.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fget_005fstr">Function: <em>char *</em> <strong>mpc_get_str</strong> <em>(int <var>b</var>, size_t <var>n</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Convert <var>op</var> to a string containing its real and imaginary parts,
separated by a space and enclosed in a pair of parentheses.
The numbers are written in base <var>b</var> (which may vary from 2 to 36) and
rounded according to <var>rnd</var>. The number of significant digits, at least 2,
is given by <var>n</var>. It is also possible to let
<var>n</var> be zero, in which case the number of digits is chosen large
enough so that re-reading the printed value with the same precision, assuming
both output and input use rounding to nearest, will recover the original value
of <var>op</var>.
Note that <code>mpc_get_str</code> uses the decimal point of the current locale
if available, and &lsquo;<samp>.</samp>&rsquo; otherwise.
</p>
<p>The string is generated using the current memory allocation function
(<code>malloc</code> by default, unless it has been modified using the custom
memory allocation interface of <code>gmp</code>); once it is not needed any more,
it should be freed by calling <code>mpc_free_str</code>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005ffree_005fstr">Function: <em>void</em> <strong>mpc_free_str</strong> <em>(char *<var>str</var>)</em></dt>
<dd><p>Free the string <var>str</var>, which needs to have been allocated by
a call to <code>mpc_get_str</code>.
</p></dd></dl>
<p>The following two functions read numbers from input streams and write
them to output streams.
When using any of these functions, you need to include <samp>stdio.h</samp>
<em>before</em> <samp>mpc.h</samp>.
</p>
<dl>
<dt id="index-mpc_005finp_005fstr">Function: <em>int</em> <strong>mpc_inp_str</strong> <em>(mpc_t <var>rop</var>, FILE *<var>stream</var>, size_t *<var>read</var>, int <var>base</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Input a string in base <var>base</var> in the same format as for <code>mpc_strtoc</code>
from stdio stream <var>stream</var>, rounded according to <var>rnd</var>, and put the
read complex number into <var>rop</var>.
If <var>stream</var> is the null pointer, <var>rop</var> is read from <code>stdin</code>.
Return the usual inexact value; if an error occurs, set <var>rop</var> to <code>NaN
+ i * NaN</code> and return -1.
If <var>read</var> is not the null pointer, it is set to the number of read
characters.
</p>
<p>Unlike <code>mpc_strtoc</code>, the function <code>mpc_inp_str</code> does not possess
perfect knowledge of the string to transform and has to read it
character by character, so it behaves slightly differently: It tries
to read a string describing a complex number and processes this string
through a call to <code>mpc_set_str</code>. Precisely, after skipping optional
whitespace, a minimal string is read according to the regular expression
<code>mpfr | '(' \s* mpfr \s+ mpfr \s* ')'</code>, where <code>\s</code> denotes a whitespace,
and <code>mpfr</code> is either a string containing neither whitespaces nor
parentheses, or <code>nan(n-char-sequence)</code> or <code>@nan@(n-char-sequence)</code>
(regardless of capitalisation) with <code>n-char-sequence</code> a string
of ascii letters, digits or <code>'_'</code>.
</p>
<p>For instance, upon input of <code>&quot;nan(13 1)&quot;</code>, the function
<code>mpc_inp_str</code> starts to recognise a value of NaN followed by an
n-char-sequence indicated by the opening parenthesis; as soon as the
space is reached, it becomes clear that the expression in parentheses
is not an n-char-sequence, and the error flag -1 is returned after 6
characters have been consumed from the stream (the whitespace itself
remaining in the stream).
The function <code>mpc_strtoc</code>, on the other hand, may track back
when reaching the whitespace; it treats the string as the two successive
complex numbers <code>NaN + i * 0</code> and <code>13 + i</code>.
It is thus recommended to have a whitespace follow each floating point number
to avoid this problem.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fout_005fstr">Function: <em>size_t</em> <strong>mpc_out_str</strong> <em>(FILE *<var>stream</var>, int <var>base</var>, size_t <var>n_digits</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Output <var>op</var> on stdio stream <var>stream</var> in
base <var>base</var>, rounded according to <var>rnd</var>, in the same format
as for <code>mpc_strtoc</code>
If <var>stream</var> is the null pointer, <var>rop</var> is written to <code>stdout</code>.
</p>
<p>Return the number of characters written.
</p></dd></dl>
<hr>
<span id="Complex-Comparison"></span><div class="header">
<p>
Next: <a href="#Projection-_0026-Decomposing" accesskey="n" rel="next">Projection &amp; Decomposing</a>, Previous: <a href="#String-and-Stream-Input-and-Output" accesskey="p" rel="prev">String and Stream Input and Output</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Comparison-Functions"></span><h3 class="section">5.5 Comparison Functions</h3>
<span id="index-Complex-comparisons-functions"></span>
<span id="index-Comparison-functions"></span>
<dl>
<dt id="index-mpc_005fcmp">Function: <em>int</em> <strong>mpc_cmp</strong> <em>(const mpc_t <var>op1</var>, const mpc_t <var>op2</var>)</em></dt>
<dt id="index-mpc_005fcmp_005fsi_005fsi">Function: <em>int</em> <strong>mpc_cmp_si_si</strong> <em>(const mpc_t <var>op1</var>, long int <var>op2r</var>, long int <var>op2i</var>)</em></dt>
<dt id="index-mpc_005fcmp_005fsi">Macro: <em>int</em> <strong>mpc_cmp_si</strong> <em>(mpc_t <var>op1</var>, long int <var>op2</var>)</em></dt>
<dd>
<p>Compare <var>op1</var> and <var>op2</var>, where in the case of <code>mpc_cmp_si_si</code>,
<var>op2</var> is taken to be <var>op2r</var> + i <var>op2i</var>.
The return value <var>c</var> can be decomposed into <code>x = MPC_INEX_RE(c)</code>
and <code>y = MPC_INEX_IM(c)</code>, such that <var>x</var> is
positive if the real part of <var>op1</var> is greater than that of <var>op2</var>,
zero if both real parts are equal, and negative if the real part of <var>op1</var>
is less than that of <var>op2</var>, and likewise for <var>y</var>.
Both <var>op1</var> and <var>op2</var> are considered to their full own precision,
which may differ.
It is not allowed that one of the operands has a NaN (Not-a-Number) part.
</p>
<p>The storage of the return value is such that equality can be simply checked
with <code>mpc_cmp (op1, op2) == 0</code>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fcmp_005fabs">Function: <em>int</em> <strong>mpc_cmp_abs</strong> <em>(const mpc_t <var>op1</var>, const mpc_t <var>op2</var>)</em></dt>
<dd>
<p>Compare the absolute values of <var>op1</var> and <var>op2</var>.
The return value is 0 if both are the same (including infinity),
positive if the absolute value of <var>op1</var> is greater than that of <var>op2</var>,
and negative if it is smaller.
If <var>op1</var> or <var>op2</var> has a real or imaginary part which is NaN,
the function behaves like <code>mpfr_cmp</code> on two real numbers of which at least
one is NaN.
</p></dd></dl>
<hr>
<span id="Projection-_0026-Decomposing"></span><div class="header">
<p>
Next: <a href="#Basic-Arithmetic" accesskey="n" rel="next">Basic Arithmetic</a>, Previous: <a href="#Complex-Comparison" accesskey="p" rel="prev">Complex Comparison</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Projection-and-Decomposing-Functions"></span><h3 class="section">5.6 Projection and Decomposing Functions</h3>
<span id="index-Projection-and-Decomposing-Functions"></span>
<dl>
<dt id="index-mpc_005freal">Function: <em>int</em> <strong>mpc_real</strong> <em>(mpfr_t <var>rop</var>, const mpc_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the real part of <var>op</var> rounded
in the direction <var>rnd</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fimag">Function: <em>int</em> <strong>mpc_imag</strong> <em>(mpfr_t <var>rop</var>, const mpc_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the value of the imaginary part of <var>op</var> rounded in the
direction <var>rnd</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005frealref">Macro: <em>mpfr_t</em> <strong>mpc_realref</strong> <em>(mpc_t <var>op</var>)</em></dt>
<dt id="index-mpc_005fimagref">Macro: <em>mpfr_t</em> <strong>mpc_imagref</strong> <em>(mpc_t <var>op</var>)</em></dt>
<dd><p>Return a reference to the real part and imaginary part of <var>op</var>,
respectively. The <code>mpfr</code> functions can be used on the result of these
macros (note that the <code>mpfr_t</code> type is itself a pointer).
</p></dd></dl>
<dl>
<dt id="index-mpc_005farg">Function: <em>int</em> <strong>mpc_arg</strong> <em>(mpfr_t <var>rop</var>, const mpc_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the argument of <var>op</var>, with a branch cut along the
negative real axis.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fproj">Function: <em>int</em> <strong>mpc_proj</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Compute a projection of <var>op</var> onto the Riemann sphere. Set <var>rop</var> to
<var>op</var> rounded in the direction <var>rnd</var>, except when at least one part of
<var>op</var> is infinite (even if the other part is a NaN) in which case the real
part of <var>rop</var> is set to plus infinity and its imaginary part to a signed
zero with the same sign as the imaginary part of <var>op</var>.
</p></dd></dl>
<hr>
<span id="Basic-Arithmetic"></span><div class="header">
<p>
Next: <a href="#Power-Functions-and-Logarithm" accesskey="n" rel="next">Power Functions and Logarithm</a>, Previous: <a href="#Projection-_0026-Decomposing" accesskey="p" rel="prev">Projection &amp; Decomposing</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Basic-Arithmetic-Functions"></span><h3 class="section">5.7 Basic Arithmetic Functions</h3>
<span id="index-Complex-arithmetic-functions"></span>
<span id="index-Arithmetic-functions"></span>
<p>All the following functions are designed in such a way that, when working
with real numbers instead of complex numbers, their complexity should
essentially be the same as with the GNU MPFR library, with only a marginal
overhead due to the GNU MPC layer.
</p>
<dl>
<dt id="index-mpc_005fadd">Function: <em>int</em> <strong>mpc_add</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fadd_005fui">Function: <em>int</em> <strong>mpc_add_ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fadd_005ffr">Function: <em>int</em> <strong>mpc_add_fr</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpfr_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <var>op1</var> <em>+</em> <var>op2</var> rounded according to <var>rnd</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fsub">Function: <em>int</em> <strong>mpc_sub</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fsub_005ffr">Function: <em>int</em> <strong>mpc_sub_fr</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpfr_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005ffr_005fsub">Function: <em>int</em> <strong>mpc_fr_sub</strong> <em>(mpc_t <var>rop</var>, const mpfr_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fsub_005fui">Function: <em>int</em> <strong>mpc_sub_ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fui_005fsub">Macro: <em>int</em> <strong>mpc_ui_sub</strong> <em>(mpc_t <var>rop</var>, unsigned long int <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fui_005fui_005fsub">Function: <em>int</em> <strong>mpc_ui_ui_sub</strong> <em>(mpc_t <var>rop</var>, unsigned long int <var>re1</var>, unsigned long int <var>im1</var>, mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <var>op1</var> - <var>op2</var> rounded according to <var>rnd</var>.
For <code>mpc_ui_ui_sub</code>, <var>op1</var> is <var>re1</var> + <var>im1</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fneg">Function: <em>int</em> <strong>mpc_neg</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to -<var>op</var> rounded according to <var>rnd</var>.
Just changes the sign if <var>rop</var> and <var>op</var> are the same variable.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fsum">Function: <em>int</em> <strong>mpc_sum</strong> <em>(mpc_t <var>rop</var>, const mpc_ptr* <var>op</var>, unsigned long <var>n</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the sum of the elements in the array <var>op</var> of
length <var>n</var>, rounded according to <var>rnd</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fmul">Function: <em>int</em> <strong>mpc_mul</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fmul_005fui">Function: <em>int</em> <strong>mpc_mul_ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fmul_005fsi">Function: <em>int</em> <strong>mpc_mul_si</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fmul_005ffr">Function: <em>int</em> <strong>mpc_mul_fr</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpfr_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <var>op1</var> times <var>op2</var> rounded according to <var>rnd</var>.
Note: for <code>mpc_mul</code>, in case <var>op1</var> and <var>op2</var> have the same value,
use <code>mpc_sqr</code> for better efficiency.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fmul_005fi">Function: <em>int</em> <strong>mpc_mul_i</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, int <var>sgn</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <var>op</var> times the imaginary unit i if <var>sgn</var> is
non-negative, set <var>rop</var> to <var>op</var> times -i otherwise,
in both cases rounded according to <var>rnd</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fsqr">Function: <em>int</em> <strong>mpc_sqr</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the square of <var>op</var> rounded according to <var>rnd</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005ffma">Function: <em>int</em> <strong>mpc_fma</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpc_t <var>op2</var>, const mpc_t <var>op3</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <var>op1</var>*<var>op2</var>+<var>op3</var>,
rounded according to <var>rnd</var>, with only one final rounding.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fdot">Function: <em>int</em> <strong>mpc_dot</strong> <em>(mpc_t <var>rop</var>, const mpc_ptr* <var>op1</var>, mpc_ptr* <var>op2</var>, unsigned long <var>n</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the dot product of the elements in the arrays <var>op1</var> and
<var>op2</var>, both of length <var>n</var>, rounded according to <var>rnd</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fdiv">Function: <em>int</em> <strong>mpc_div</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fdiv_005fui">Function: <em>int</em> <strong>mpc_div_ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fdiv_005ffr">Function: <em>int</em> <strong>mpc_div_fr</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpfr_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fui_005fdiv">Function: <em>int</em> <strong>mpc_ui_div</strong> <em>(mpc_t <var>rop</var>, unsigned long int <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005ffr_005fdiv">Function: <em>int</em> <strong>mpc_fr_div</strong> <em>(mpc_t <var>rop</var>, const mpfr_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <var>op1</var>/<var>op2</var> rounded according to <var>rnd</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fconj">Function: <em>int</em> <strong>mpc_conj</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the conjugate of <var>op</var> rounded according to <var>rnd</var>.
Just changes the sign of the imaginary part
if <var>rop</var> and <var>op</var> are the same variable.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fabs">Function: <em>int</em> <strong>mpc_abs</strong> <em>(mpfr_t <var>rop</var>, const mpc_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set the floating-point number <var>rop</var> to the absolute value of <var>op</var>,
rounded in the direction <var>rnd</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fnorm">Function: <em>int</em> <strong>mpc_norm</strong> <em>(mpfr_t <var>rop</var>, const mpc_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set the floating-point number <var>rop</var> to the norm of <var>op</var>
(i.e., the square of its absolute value),
rounded in the direction <var>rnd</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fmul_005f2ui">Function: <em>int</em> <strong>mpc_mul_2ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fmul_005f2si">Function: <em>int</em> <strong>mpc_mul_2si</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <var>op1</var> times 2 raised to <var>op2</var>
rounded according to <var>rnd</var>. Just modifies the exponents
of the real and imaginary parts by <var>op2</var>
when <var>rop</var> and <var>op1</var> are identical.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fdiv_005f2ui">Function: <em>int</em> <strong>mpc_div_2ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fdiv_005f2si">Function: <em>int</em> <strong>mpc_div_2si</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <var>op1</var> divided by 2 raised to <var>op2</var>
rounded according to <var>rnd</var>. Just modifies the exponents
of the real and imaginary parts by <var>op2</var>
when <var>rop</var> and <var>op1</var> are identical.
</p></dd></dl>
<hr>
<span id="Power-Functions-and-Logarithm"></span><div class="header">
<p>
Next: <a href="#Trigonometric-Functions" accesskey="n" rel="next">Trigonometric Functions</a>, Previous: <a href="#Basic-Arithmetic" accesskey="p" rel="prev">Basic Arithmetic</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Power-Functions-and-Logarithm-1"></span><h3 class="section">5.8 Power Functions and Logarithm</h3>
<span id="index-Power-functions"></span>
<span id="index-Logarithm"></span>
<dl>
<dt id="index-mpc_005fsqrt">Function: <em>int</em> <strong>mpc_sqrt</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the square root of <var>op</var> rounded according to <var>rnd</var>.
The returned value <var>rop</var> has a non-negative real part, and if its real
part is zero, a non-negative imaginary part.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fpow">Function: <em>int</em> <strong>mpc_pow</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fpow_005fd">Function: <em>int</em> <strong>mpc_pow_d</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, double <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fpow_005fld">Function: <em>int</em> <strong>mpc_pow_ld</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, long double <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fpow_005fsi">Function: <em>int</em> <strong>mpc_pow_si</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, long <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fpow_005fui">Function: <em>int</em> <strong>mpc_pow_ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fpow_005fz">Function: <em>int</em> <strong>mpc_pow_z</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpz_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fpow_005ffr">Function: <em>int</em> <strong>mpc_pow_fr</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpfr_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to <var>op1</var> raised to the power <var>op2</var>, rounded according
to <var>rnd</var>.
For <code>mpc_pow_d</code>, <code>mpc_pow_ld</code>, <code>mpc_pow_si</code>, <code>mpc_pow_ui</code>,
<code>mpc_pow_z</code> and <code>mpc_pow_fr</code>,
the imaginary part of <var>op2</var> is considered as +0.
When both <var>op1</var> and <var>op2</var> are zero, the result has real part 1,
and imaginary part 0, with sign being the opposite of that of <var>op2</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fexp">Function: <em>int</em> <strong>mpc_exp</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the exponential of <var>op</var>,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005flog">Function: <em>int</em> <strong>mpc_log</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005flog10">Function: <em>int</em> <strong>mpc_log10</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the natural and base-10 logarithm of <var>op</var> respectively,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
The principal branch is chosen, with the branch cut on the negative real axis,
so that the imaginary part of the result lies in
]-Pi , Pi]
and
]-Pi/log(10) , Pi/log(10)]
respectively.
</p></dd></dl>
<dl>
<dt id="index-mpc_005frootofunity">Function: <em>int</em> <strong>mpc_rootofunity</strong> <em>(mpc_t <var>rop</var>, unsigned long int <var>n</var>, unsigned long int <var>k</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the standard primitive <var>n</var>-th root of unity raised to the power <var>k</var>, that is,
<em>exp (2 Pi i k / n)</em>,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
</p></dd></dl>
<hr>
<span id="Trigonometric-Functions"></span><div class="header">
<p>
Next: <a href="#Miscellaneous-Complex-Functions" accesskey="n" rel="next">Miscellaneous Complex Functions</a>, Previous: <a href="#Power-Functions-and-Logarithm" accesskey="p" rel="prev">Power Functions and Logarithm</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Trigonometric-Functions-1"></span><h3 class="section">5.9 Trigonometric Functions</h3>
<span id="index-Trigonometric-functions"></span>
<dl>
<dt id="index-mpc_005fsin">Function: <em>int</em> <strong>mpc_sin</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fcos">Function: <em>int</em> <strong>mpc_cos</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005ftan">Function: <em>int</em> <strong>mpc_tan</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the sine, cosine, tangent of <var>op</var>,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fsin_005fcos">Function: <em>int</em> <strong>mpc_sin_cos</strong> <em>(mpc_t <var>rop_sin</var>, mpc_t <var>rop_cos</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd_sin</var>, mpc_rnd_t <var>rnd_cos</var>)</em></dt>
<dd><p>Set <var>rop_sin</var> to the sine of <var>op</var>,
rounded according to <var>rnd_sin</var> with the precision of <var>rop_sin</var>,
and <var>rop_cos</var> to the cosine of <var>op</var>,
rounded according to <var>rnd_cos</var> with the precision of <var>rop_cos</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fsinh">Function: <em>int</em> <strong>mpc_sinh</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fcosh">Function: <em>int</em> <strong>mpc_cosh</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005ftanh">Function: <em>int</em> <strong>mpc_tanh</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the hyperbolic sine, hyperbolic cosine, hyperbolic tangent of <var>op</var>,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fasin">Function: <em>int</em> <strong>mpc_asin</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005facos">Function: <em>int</em> <strong>mpc_acos</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fatan">Function: <em>int</em> <strong>mpc_atan</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the inverse sine, inverse cosine, inverse tangent of <var>op</var>,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fasinh">Function: <em>int</em> <strong>mpc_asinh</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005facosh">Function: <em>int</em> <strong>mpc_acosh</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dt id="index-mpc_005fatanh">Function: <em>int</em> <strong>mpc_atanh</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em></dt>
<dd><p>Set <var>rop</var> to the inverse hyperbolic sine, inverse hyperbolic cosine,
inverse hyperbolic tangent of <var>op</var>,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
The branch cut of <code>mpc_acosh</code> is
(-Inf, 1)
</p></dd></dl>
<hr>
<span id="Miscellaneous-Complex-Functions"></span><div class="header">
<p>
Next: <a href="#Advanced-Functions" accesskey="n" rel="next">Advanced Functions</a>, Previous: <a href="#Trigonometric-Functions" accesskey="p" rel="prev">Trigonometric Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Miscellaneous-Functions"></span><h3 class="section">5.10 Miscellaneous Functions</h3>
<span id="index-Miscellaneous-complex-functions"></span>
<dl>
<dt id="index-mpc_005furandom">Function: <em>int</em> <strong>mpc_urandom</strong> <em>(mpc_t <var>rop</var>, gmp_randstate_t <var>state</var>)</em></dt>
<dd><p>Generate a uniformly distributed random complex in the unit square <em>[0,
1] x [0, 1]</em>. Return 0, unless an exponent in the real or imaginary part
is not in the current exponent range, in which case that part is set to NaN
and a zero value is returned. The second argument is a <code>gmp_randstate_t</code>
structure which should be created using the GMP <code>rand_init</code> function, see
the GMP manual.
</p></dd></dl>
<dl>
<dt id="index-mpc_005fget_005fversion">Function: <em>const char *</em> <strong>mpc_get_version</strong> <em>(void)</em></dt>
<dd><p>Return the GNU MPC version, as a null-terminated string.
</p></dd></dl>
<dl>
<dt id="index-MPC_005fVERSION">Macro: <strong>MPC_VERSION</strong></dt>
<dt id="index-MPC_005fVERSION_005fMAJOR">Macro: <strong>MPC_VERSION_MAJOR</strong></dt>
<dt id="index-MPC_005fVERSION_005fMINOR">Macro: <strong>MPC_VERSION_MINOR</strong></dt>
<dt id="index-MPC_005fVERSION_005fPATCHLEVEL">Macro: <strong>MPC_VERSION_PATCHLEVEL</strong></dt>
<dt id="index-MPC_005fVERSION_005fSTRING">Macro: <strong>MPC_VERSION_STRING</strong></dt>
<dd><p><code>MPC_VERSION</code> is the version of GNU MPC as a preprocessing constant.
<code>MPC_VERSION_MAJOR</code>, <code>MPC_VERSION_MINOR</code> and
<code>MPC_VERSION_PATCHLEVEL</code> are respectively the major, minor and
patch level of GNU MPC version, as preprocessing constants.
<code>MPC_VERSION_STRING</code> is the version as a string constant, which
can be compared to the result of <code>mpc_get_version</code> to check at
run time the header file and library used match:
</p><div class="example">
<pre class="example">if (strcmp (mpc_get_version (), MPC_VERSION_STRING))
  fprintf (stderr, &quot;Warning: header and library do not match\n&quot;);
</pre></div>
<p>Note: Obtaining different strings is not necessarily an error, as in
general, a program compiled with some old GNU MPC version can be
dynamically linked with a newer GNU MPC library version (if allowed by the
library versioning system).
</p></dd></dl>
<dl>
<dt id="index-MPC_005fVERSION_005fNUM">Macro: <em>long</em> <strong>MPC_VERSION_NUM</strong> <em>(<var>major</var>, <var>minor</var>, <var>patchlevel</var>)</em></dt>
<dd><p>Create an integer in the same format as used by <code>MPC_VERSION</code> from the
given <var>major</var>, <var>minor</var> and <var>patchlevel</var>.
Here is an example of how to check the GNU MPC version at compile time:
</p><div class="example">
<pre class="example">#if (!defined(MPC_VERSION) || (MPC_VERSION&lt;MPC_VERSION_NUM(2,1,0)))
# error &quot;Wrong GNU MPC version.&quot;
#endif
</pre></div>
</dd></dl>
<hr>
<span id="Advanced-Functions"></span><div class="header">
<p>
Next: <a href="#Internals" accesskey="n" rel="next">Internals</a>, Previous: <a href="#Miscellaneous-Complex-Functions" accesskey="p" rel="prev">Miscellaneous Complex Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Advanced-Functions-1"></span><h3 class="section">5.11 Advanced Functions</h3>
<dl>
<dt id="index-MPC_005fSET_005fX_005fY">Macro: <strong>MPC_SET_X_Y</strong> <em>(<var>real_suffix</var>, <var>imag_suffix</var>, <var>rop</var>, <var>real</var>, <var>imag</var>, <var>rnd</var>)</em></dt>
<dd><p>The macro MPC_SET_X_Y is designed to serve as the body of an assignment
function and cannot be used by itself.
The <var>real_suffix</var> and <var>imag_suffix</var> parameters are the
types of the real and imaginary part, that is, the <code>x</code> in the
<code>mpfr_set_x</code> function one would use to set the part;
for the mpfr type, use <code>fr</code>.
<var>real</var> (respectively <var>imag</var>) is the value you want to assign to the
real (resp. imaginary) part, its type must conform to <var>real_suffix</var>
(resp. <var>imag_suffix</var>).
<var>rnd</var> is the <code>mpc_rnd_t</code> rounding mode.
The return value is the usual inexact value (see <a href="constant.GNU_MPC_Basics.html#return_002dvalue">Return
Value</a>).
</p>
<p>For instance, you can define mpc_set_ui_fr as follows:
</p><div class="example">
<pre class="example">int mpc_set_ui_fr (mpc_t rop, unsigned long int re, mpfr_t im, mpc_rnd_t rnd)
    MPC_SET_X_Y (ui, fr, rop, re, im, rnd);
</pre></div>
</dd></dl>
<hr>
<span id="Internals"></span><div class="header">
<p>
Previous: <a href="#Advanced-Functions" accesskey="p" rel="prev">Advanced Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Internals-1"></span><h3 class="section">5.12 Internals</h3>
<p>These macros and
functions are mainly designed for the implementation of GNU MPC,
but may be useful for users too.
However, no upward compatibility is guaranteed.
You need to include <code>mpc-impl.h</code> to use them.
</p>
<p>The macro <code>MPC_MAX_PREC(z)</code> gives the maximum of the precisions
of the real and imaginary parts of a complex number.
</p>
<hr>
<div class="header">
<p>
Previous: <a href="#Advanced-Functions" accesskey="p" rel="prev">Advanced Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div></div></details></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="gmp_mpfr_sys" data-search-index-js="../../../search-index.js" data-search-js="../../../search.js"></div>
</body></html>