<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This constant is a place-holder for documentation; do not use it in code."><meta name="keywords" content="rust, rustlang, rust-lang, Low_level_Functions"><title>Low_level_Functions in gmp_mpfr_sys::C::GMP - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../gmp_mpfr_sys/index.html'><div class='logo-container rust-logo'><img src='data:image&#x2F;svg+xml;base64,
PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCEtLSBDcmVhdGVkIHdpdGggSW5rc2NhcGUgKGh0dHA6Ly93
d3cuaW5rc2NhcGUub3JnLykgLS0+Cjxzdmcgd2lkdGg9IjEyOCIgaGVpZ2h0PSIxMjgiIHZlcnNpb249IjEuMSIgdmlld0JveD0i
MCAwIDMzLjg2NjY2NiAzMy44NjY2NjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6Y2M9Imh0dHA6
Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxu
czpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogPG1ldGFkYXRhPgogIDxyZGY6UkRG
PgogICA8Y2M6V29yayByZGY6YWJvdXQ9IiI+CiAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgIDxk
Yzp0eXBlIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiLz4KICAgIDxkYzp0aXRs
ZS8+CiAgIDwvY2M6V29yaz4KICA8L3JkZjpSREY+CiA8L21ldGFkYXRhPgogPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAtMjYz
LjEzKSI+CiAgPHBhdGggZD0ibTMzLjg2NyAyODAuMDdhMTYuOTMzIDE2LjkzMyAwIDAgMSAtMTYuOTMzIDE2LjkzMyAxNi45MzMg
MTYuOTMzIDAgMCAxIC0xNi45MzMgLTE2LjkzMyAxNi45MzMgMTYuOTMzIDAgMCAxIDE2LjkzMyAtMTYuOTMzIDE2LjkzMyAxNi45
MzMgMCAwIDEgMTYuOTMzIDE2LjkzM3oiIGZpbGw9IiNmZmZmYzAiLz4KICA8ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0
cm9rZS13aWR0aD0iLjI2NDU4cHgiPgogICA8ZyBhcmlhLWxhYmVsPSI2Ij4KICAgIDxwYXRoIGQ9Im0xNC40NzEgMjg0LjA3YzIu
MjAxMyAwIDQuMDM1OC0xLjQ2NzYgNC4wMzU4LTMuOTYyNCAwLTIuNDk0OC0xLjU0MDktMy41OTU1LTMuNTIyMS0zLjU5NTUtMC42
MjM3MSAwLTEuNjE0MyAwLjQwMzU4LTIuMTgzIDEuMTU1NyAwLjEyODQxLTIuMzQ4MSAxLjAwODktMy4xMzY5IDIuMTQ2My0zLjEz
NjkgMC42NjA0IDAgMS4zOTQyIDAuNDAzNTggMS43NjExIDAuODA3MTZsMS42NTEtMS44NzExYy0wLjc3MDQ3LTAuNzcwNDctMS45
ODEyLTEuNDY3Ni0zLjYzMjItMS40Njc2LTIuNDk0OCAwLTQuODA2MiAyLjAxNzktNC44MDYyIDYuMjM3MXMyLjMxMTQgNS44MzM1
IDQuNTQ5NCA1LjgzMzV6bS0wLjA3MzM4LTIuMzQ4MWMtMC41Njg2OCAwLTEuMjY1OC0wLjM4NTI0LTEuNTIyNi0yLjAxNzkgMC4z
NjY4OS0wLjY5NzA5IDAuOTM1NTctMC45OTA2IDEuNDg1OS0wLjk5MDYgMC42NjA0IDAgMS4yODQxIDAuMjc1MTYgMS4yODQxIDEu
Mzk0MiAwIDEuMjI5MS0wLjU4NzAyIDEuNjE0My0xLjI0NzQgMS42MTQzeiIgZmlsbD0iIzAwMTAzMCIgc3Ryb2tlPSJub25lIi8+
CiAgIDwvZz4KICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoMTUuNTE1KSIgYXJpYS1sYWJlbD0iMiI+CiAgICA8cGF0aCBkPSJtOTgu
MDM1IDI2Ny45NWg1LjA0NjF2LTEuMzk5OGgtMS40NDVjLTAuMzM4NjcgMC0wLjgzNTM4IDAuMDQ1Mi0xLjE5NjYgMC4wOTAzIDEu
MTYyOC0xLjIxOTIgMi4yOTE2LTIuNTA2MSAyLjI5MTYtMy43MTQgMC0xLjM3NzItMC45NTk1NS0yLjI4MDQtMi4zNzA3LTIuMjgw
NC0xLjAyNzMgMC0xLjY5MzMgMC4zODM4Mi0yLjQwNDUgMS4xNDAybDAuOTAzMTEgMC44OTE4MmMwLjM2MTI0LTAuMzgzODIgMC43
NTYzNi0wLjczMzc4IDEuMjc1Ni0wLjczMzc4IDAuNjIwODkgMCAxLjAxNiAwLjM4MzgzIDEuMDE2IDEuMDgzNyAwIDEuMDE2LTEu
Mjg2OSAyLjI0NjUtMy4xMTU3IDMuOTczN3oiIGZpbGw9IiMwMDEwMzAiIGZpbGwtb3BhY2l0eT0iLjk3MjU1IiBzdHJva2U9Im5v
bmUiLz4KICAgPC9nPgogICA8ZyB0cmFuc2Zvcm09InJvdGF0ZSgtMTEuMDMzKSIgYXJpYS1sYWJlbD0iOCI+CiAgICA8cGF0aCBk
PSJtLTM4LjkyIDI5MC43NmMxLjI3NDIgMCAyLjEyMzctMC43NDA4MyAyLjEyMzctMS43MDg4IDAtMC44Mzk2Mi0wLjUwMzc3LTEu
MzAzOS0xLjA4NjYtMS42Mjk4di0wLjAzOTVjMC40MDQ5OS0wLjI5NjMzIDAuODM5NjEtMC44MTk4NSAwLjgzOTYxLTEuNDQyMiAw
LTEuMDE3NC0wLjcyMTA4LTEuNjk5LTEuODQ3MS0xLjY5OS0xLjA4NjYgMC0xLjg5NjUgMC42NTE5My0xLjg5NjUgMS42NjkzIDAg
MC42NjE4MSAwLjM4NTIzIDEuMTI2MSAwLjg2OTI0IDEuNDcxOHYwLjAzOTVjLTAuNTkyNjcgMC4zMTYwOS0xLjEzNTkgMC44Mjk3
NC0xLjEzNTkgMS42MTAxIDAgMS4wMTc0IDAuOTA4NzYgMS43Mjg2IDIuMTMzNiAxLjcyODZ6bTAuNDE0ODctMy42NjQ2Yy0wLjcw
MTMyLTAuMjc2NTgtMS4yNjQ0LTAuNTUzMTYtMS4yNjQ0LTEuMTg1MyAwLTAuNTQzMjggMC4zNzUzNi0wLjg1OTM2IDAuODU5Mzct
MC44NTkzNiAwLjU4Mjc5IDAgMC45Mjg1MSAwLjQwNDk4IDAuOTI4NTEgMC45NTgxNCAwIDAuMzk1MTEtMC4xODc2OCAwLjc1MDcx
LTAuNTIzNTIgMS4wODY2em0tMC4zOTUxMSAyLjg1NDdjLTAuNjQyMDYgMC0xLjE1NTctMC40MTQ4Ni0xLjE1NTctMS4wMzcyIDAt
MC40ODQwMSAwLjI4NjQ2LTAuODg5IDAuNjgxNTctMS4xNzU1IDAuODQ5NDkgMC4zNDU3MiAxLjUxMTMgMC41OTI2NyAxLjUxMTMg
MS4yNzQyIDAgMC41ODI3OS0wLjQzNDYyIDAuOTM4MzktMS4wMzcyIDAuOTM4Mzl6IiBmaWxsPSIjMDAxMDMwIiBmaWxsLW9wYWNp
dHk9Ii45NDExOCIgc3Ryb2tlPSJub25lIi8+CiAgIDwvZz4KICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoNi41MDA4KSIgYXJpYS1s
YWJlbD0iMyI+CiAgICA8cGF0aCBkPSJtMzkuMzAyIDI4My42NGMxLjAzMjkgMCAxLjg4ODEtMC41NzU3MyAxLjg4ODEtMS41NTc5
IDAtMC43MTEyLTAuNDgyNi0xLjE2ODQtMS4xMTc2LTEuMzM3N3YtMC4wMzM5YzAuNTg0Mi0wLjIyODYgMC45Mzk4LTAuNjM1IDAu
OTM5OC0xLjIzNjEgMC0wLjkxNDQtMC43MTEyLTEuNDIyNC0xLjc0NDEtMS40MjI0LTAuNjQzNDcgMC0xLjE1OTkgMC4yNzA5My0x
LjYxNzEgMC42NzczM2wwLjQ5OTUzIDAuNjAxMTRjMC4zMzAyLTAuMzA0OCAwLjY2MDQtMC41MDggMS4wODM3LTAuNTA4IDAuNDkx
MDcgMCAwLjc5NTg3IDAuMjcwOTMgMC43OTU4NyAwLjcxOTY3IDAgMC40OTk1My0wLjM0NzEzIDAuODYzNi0xLjQwNTUgMC44NjM2
djAuNzExMmMxLjIyNzcgMCAxLjU4MzMgMC4zNTU2IDEuNTgzMyAwLjkxNDQgMCAwLjUwOC0wLjQwNjQgMC44MTI4LTAuOTkwNiAw
LjgxMjgtMC41NDE4NyAwLTAuOTU2NzMtMC4yNjI0Ny0xLjI3ODUtMC41OTI2N2wtMC40NjU2NyAwLjYyNjUzYzAuMzgxIDAuNDIz
MzQgMC45NTY3MyAwLjc2MiAxLjgyODggMC43NjJ6IiBmaWxsPSIjMDAxMDMwIiBmaWxsLW9wYWNpdHk9Ii44Nzg0MyIgc3Ryb2tl
PSJub25lIi8+CiAgIDwvZz4KICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoOC4zNTYpIiBhcmlhLWxhYmVsPSIxIj4KICAgIDxwYXRo
IGQ9Im00Ni40MDUgMjY4LjloMy4yNDI3di0wLjc5NTg3aC0xLjA1ODN2LTQuNTg4OWgtMC43MjgxM2MtMC4zMzg2NyAwLjIwMzIt
MC43MTEyIDAuMzM4NjYtMS4yNDQ2IDAuNDQwMjZ2MC42MDk2aDAuOTkwNnYzLjUzOTFoLTEuMjAyM3oiIGZpbGw9IiMwMDEwMzAi
IGZpbGwtb3BhY2l0eT0iLjc1Mjk0IiBzdHJva2U9Im5vbmUiLz4KICAgPC9nPgogICA8ZyB0cmFuc2Zvcm09InJvdGF0ZSgxMi44
NjEpIiBhcmlhLWxhYmVsPSI4Ij4KICAgIDxwYXRoIGQ9Im04NS4wMzYgMjYxLjYzYzEuMDkyMiAwIDEuODIwMy0wLjYzNSAxLjgy
MDMtMS40NjQ3IDAtMC43MTk2Ny0wLjQzMTgtMS4xMTc2LTAuOTMxMzMtMS4zOTd2LTAuMDMzOWMwLjM0NzEzLTAuMjU0IDAuNzE5
NjctMC43MDI3MyAwLjcxOTY3LTEuMjM2MSAwLTAuODcyMDctMC42MTgwNy0xLjQ1NjMtMS41ODMzLTEuNDU2My0wLjkzMTMzIDAt
MS42MjU2IDAuNTU4OC0xLjYyNTYgMS40MzA5IDAgMC41NjcyNiAwLjMzMDIgMC45NjUyIDAuNzQ1MDcgMS4yNjE1djAuMDMzOWMt
MC41MDggMC4yNzA5My0wLjk3MzY3IDAuNzExMi0wLjk3MzY3IDEuMzgwMSAwIDAuODcyMDcgMC43Nzg5MyAxLjQ4MTcgMS44Mjg4
IDEuNDgxN3ptMC4zNTU2LTMuMTQxMWMtMC42MDExMy0wLjIzNzA3LTEuMDgzNy0wLjQ3NDE0LTEuMDgzNy0xLjAxNiAwLTAuNDY1
NjcgMC4zMjE3My0wLjczNjYgMC43MzY2LTAuNzM2NiAwLjQ5OTUzIDAgMC43OTU4NyAwLjM0NzEzIDAuNzk1ODcgMC44MjEyNiAw
IDAuMzM4NjctMC4xNjA4NyAwLjY0MzQ3LTAuNDQ4NzMgMC45MzEzNHptLTAuMzM4NjcgMi40NDY5Yy0wLjU1MDMzIDAtMC45OTA2
LTAuMzU1Ni0wLjk5MDYtMC44ODkgMC0wLjQxNDg2IDAuMjQ1NTMtMC43NjIgMC41ODQyLTEuMDA3NSAwLjcyODEzIDAuMjk2MzMg
MS4yOTU0IDAuNTA4IDEuMjk1NCAxLjA5MjIgMCAwLjQ5OTUzLTAuMzcyNTMgMC44MDQzMy0wLjg4OSAwLjgwNDMzeiIgZmlsbD0i
IzAwMTAzMCIgZmlsbC1vcGFjaXR5PSIuNjI3NDUiIHN0cm9rZT0ibm9uZSIvPgogICA8L2c+CiAgIDxnIHRyYW5zZm9ybT0icm90
YXRlKDQuMzA5OSkiIGFyaWEtbGFiZWw9IjUiPgogICAgPHBhdGggZD0ibTQ2LjM0MSAyODkuNDljMC45OTA2IDAgMS44OTY1LTAu
Njc3MzQgMS44OTY1LTEuODU0MiAwLTEuMTU5OS0wLjc3MDQ3LTEuNjg0OS0xLjY5MzMtMS42ODQ5LTAuMjc5NCAwLTAuNDgyNiAw
LjA2NzctMC43MTEyIDAuMTc3OGwwLjExMDA3LTEuMzAzOWgyLjAzMnYtMC44MjEyN2gtMi44Nzg3bC0wLjE2MDg3IDIuNjU4NSAw
LjQ2NTY3IDAuMjk2MzNjMC4zMjE3My0wLjIxMTY3IDAuNTE2NDctMC4zMDQ4IDAuODYzNi0wLjMwNDggMC41OTI2NyAwIDAuOTkw
NiAwLjM2NDA3IDAuOTkwNiAxLjAwNzUgMCAwLjY1MTk0LTAuNDQwMjcgMS4wMzI5LTEuMDQxNCAxLjAzMjktMC41NDE4NyAwLTAu
OTM5OC0wLjI3MDk0LTEuMjYxNS0wLjU3NTc0bC0wLjQ0ODczIDAuNjI2NTRjMC4zOTc5MyAwLjM5NzkzIDAuOTY1MiAwLjc0NTA3
IDEuODM3MyAwLjc0NTA3eiIgZmlsbD0iIzAwMTAzMCIgZmlsbC1vcGFjaXR5PSIuNTAxOTYiIHN0cm9rZT0ibm9uZSIvPgogICA8
L2c+CiAgPC9nPgogIDxnIGZpbGw9IiMwMDEwMzAiIGZpbGwtb3BhY2l0eT0iLjM3NjQ3IiBzdHJva2U9IiMwMDAiIHN0cm9rZS13
aWR0aD0iLjI2NDU4cHgiIGFyaWEtbGFiZWw9IjMiPgogICA8cGF0aCBkPSJtOS44ODU5IDI5My40NmMxLjAzMjkgMCAxLjg4ODEt
MC41NzU3NCAxLjg4ODEtMS41NTc5IDAtMC43MTEyLTAuNDgyNi0xLjE2ODQtMS4xMTc2LTEuMzM3N3YtMC4wMzM5YzAuNTg0Mi0w
LjIyODYgMC45Mzk4LTAuNjM1IDAuOTM5OC0xLjIzNjEgMC0wLjkxNDQtMC43MTEyLTEuNDIyNC0xLjc0NDEtMS40MjI0LTAuNjQz
NDcgMC0xLjE1OTkgMC4yNzA5My0xLjYxNzEgMC42NzczM2wwLjQ5OTUzIDAuNjAxMTNjMC4zMzAyLTAuMzA0OCAwLjY2MDQtMC41
MDggMS4wODM3LTAuNTA4IDAuNDkxMDcgMCAwLjc5NTg3IDAuMjcwOTQgMC43OTU4NyAwLjcxOTY3IDAgMC40OTk1My0wLjM0NzEz
IDAuODYzNi0xLjQwNTUgMC44NjM2djAuNzExMmMxLjIyNzcgMCAxLjU4MzMgMC4zNTU2IDEuNTgzMyAwLjkxNDQgMCAwLjUwOC0w
LjQwNjQgMC44MTI4LTAuOTkwNiAwLjgxMjgtMC41NDE4NyAwLTAuOTU2NzMtMC4yNjI0Ny0xLjI3ODUtMC41OTI2N2wtMC40NjU2
NyAwLjYyNjU0YzAuMzgxIDAuNDIzMzMgMC45NTY3MyAwLjc2MiAxLjgyODggMC43NjJ6IiBmaWxsPSIjMDAxMDMwIiBmaWxsLW9w
YWNpdHk9Ii4zNzY0NyIgc3Ryb2tlPSJub25lIi8+CiAgPC9nPgogIDxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMCIgc3Ryb2tl
LXdpZHRoPSIuMjY0NThweCI+CiAgIDxnIHRyYW5zZm9ybT0icm90YXRlKC0xMS4zNTIpIiBhcmlhLWxhYmVsPSIwIj4KICAgIDxw
YXRoIGQ9Im0tNTEuNDcxIDI3Ni4xN2MxLjExNzYgMCAxLjgyODgtMC45OTkwNyAxLjgyODgtMi44MTk0IDAtMS44MTE5LTAuNzEx
Mi0yLjc2ODYtMS44Mjg4LTIuNzY4NnMtMS44Mjg4IDAuOTQ4MjctMS44Mjg4IDIuNzY4NiAwLjcxMTIgMi44MTk0IDEuODI4OCAy
LjgxOTR6bTAtMC43NjJjLTAuNTE2NDcgMC0wLjg5NzQ3LTAuNTMzNC0wLjg5NzQ3LTIuMDU3NHMwLjM4MS0yLjAwNjYgMC44OTc0
Ny0yLjAwNjZjMC41MjQ5MyAwIDAuODk3NDcgMC40ODI2IDAuODk3NDcgMi4wMDY2cy0wLjM3MjUzIDIuMDU3NC0wLjg5NzQ3IDIu
MDU3NHoiIGZpbGw9IiMwMDEwMzAiIGZpbGwtb3BhY2l0eT0iLjI1MDk4IiBzdHJva2U9Im5vbmUiLz4KICAgPC9nPgogICA8ZyB0
cmFuc2Zvcm09InJvdGF0ZSgyMi41MDYpIiBhcmlhLWxhYmVsPSI3Ij4KICAgIDxwYXRoIGQ9Im0xMTguMjEgMjQzLjA4aDAuOTkw
NmMwLjA5MzEtMi4wOTk3IDAuMzEzMjctMy4yMjU4IDEuNTc0OC00Ljc5MjF2LTAuNTkyNjdoLTMuNjE1M3YwLjgyMTI3aDIuNTQ4
NWMtMS4wNDE0IDEuNDQ3OC0xLjQwNTUgMi42NTAxLTEuNDk4NiA0LjU2MzV6IiBmaWxsPSIjMDAxMDMwIiBmaWxsLW9wYWNpdHk9
Ii4xMjU0OSIgc3Ryb2tlPSJub25lIi8+CiAgIDwvZz4KICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoLTkuNzI3MykiIGFyaWEtbGFi
ZWw9IjEiPgogICAgPHBhdGggZD0ibS0xOC4yOTkgMjgyLjc5aDMuMjQyN3YtMC43OTU4N2gtMS4wNTgzdi00LjU4ODloLTAuNzI4
MTNjLTAuMzM4NjcgMC4yMDMyLTAuNzExMiAwLjMzODY3LTEuMjQ0NiAwLjQ0MDI3djAuNjA5NmgwLjk5MDZ2My41MzkxaC0xLjIw
MjN6IiBmaWxsPSIjMDAxMDMwIiBmaWxsLW9wYWNpdHk9Ii4wNjI3NDUiIHN0cm9rZT0ibm9uZSIvPgogICA8L2c+CiAgPC9nPgog
IDxnIGZpbGw9IiMyNDEwMzAiIGFyaWEtbGFiZWw9Ii4iPgogICA8cGF0aCBkPSJtMjAuOTIgMjgzLjk4YzAuNjU0NzYgMCAxLjEy
ODktMC41MTkyOSAxLjEyODktMS4xNzQgMC0wLjY1NDc2LTAuNDc0MTMtMS4xNzQtMS4xMjg5LTEuMTc0LTAuNjU0NzYgMC0xLjEy
ODkgMC41MTkyOS0xLjEyODkgMS4xNzQgMCAwLjY1NDc1IDAuNDc0MTMgMS4xNzQgMS4xMjg5IDEuMTc0eiIgZmlsbD0iIzAwMTAz
MCIvPgogIDwvZz4KIDwvZz4KPC9zdmc+Cg==
' alt='logo'></div></a><div class="sidebar-elems"><h2 class="location">Other items in<br><a href="../../index.html">gmp_mpfr_sys</a>::<wbr><a href="../index.html">C</a>::<wbr><a href="index.html">GMP</a></h2><div id="sidebar-vars" data-name="Low_level_Functions" data-ty="constant" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Constant <a href="../../index.html">gmp_mpfr_sys</a>::<wbr><a href="../index.html">C</a>::<wbr><a href="index.html">GMP</a>::<wbr><a class="constant" href="#">Low_level_Functions</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/gmp_mpfr_sys/C.rs.html#118" title="goto source code">[src]</a></span></h1><div class="docblock item-decl"><pre class="rust const"><code>pub const Low_level_Functions: <a class="primitive" href="https://doc.rust-lang.org/1.58.1/core/primitive.unit.html">()</a>;</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This constant is a place-holder for documentation; do not use it in code.</p>
<hr />
<div><span id="start"></span></div>
<span id="Low_002dlevel-Functions"></span><div class="header">
<p>
Next: <a href="constant.Random_Number_Functions.html#Random-Number-Functions" accesskey="n" rel="next">Random Number Functions</a>, Previous: <a href="constant.Floating_point_Functions.html#Floating_002dpoint-Functions" accesskey="p" rel="prev">Floating-point Functions</a>, Up: <a href="index.html#start" accesskey="u" rel="up">Top</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Low_002dlevel-Functions-1"></span><h2 class="chapter">8 Low-level Functions</h2>
<span id="index-Low_002dlevel-functions"></span>
<p>This chapter describes low-level GMP functions, used to implement the
high-level GMP functions, but also intended for time-critical user code.
</p>
<p>These functions start with the prefix <code>mpn_</code>.
</p>
<p>The <code>mpn</code> functions are designed to be as fast as possible, <strong>not</strong>
to provide a coherent calling interface.  The different functions have somewhat
similar interfaces, but there are variations that make them hard to use.  These
functions do as little as possible apart from the real multiple precision
computation, so that no time is spent on things that not all callers need.
</p>
<p>A source operand is specified by a pointer to the least significant limb and a
limb count.  A destination operand is specified by just a pointer.  It is the
responsibility of the caller to ensure that the destination has enough space
for storing the result.
</p>
<p>With this way of specifying operands, it is possible to perform computations on
subranges of an argument, and store the result into a subrange of a
destination.
</p>
<p>A common requirement for all functions is that each source area needs at least
one limb.  No size argument may be zero.  Unless otherwise stated, in-place
operations are allowed where source and destination are the same, but not where
they only partly overlap.
</p>
<p>The <code>mpn</code> functions are the base for the implementation of the
<code>mpz_</code>, <code>mpf_</code>, and <code>mpq_</code> functions.
</p>
<p>This example adds the number beginning at <var>s1p</var> and the number beginning at
<var>s2p</var> and writes the sum at <var>destp</var>.  All areas have <var>n</var> limbs.
</p>
<div class="example">
<pre class="example">cy = mpn_add_n (destp, s1p, s2p, n)
</pre></div>
<p>It should be noted that the <code>mpn</code> functions make no attempt to identify
high or low zero limbs on their operands, or other special forms.  On random
data such cases will be unlikely and it&rsquo;d be wasteful for every function to
check every time.  An application knowing something about its data can take
steps to trim or perhaps split its calculations.
</p>
<br>
<p>In the notation used below, a source operand is identified by the pointer to
the least significant limb, and the limb count in braces.  For example,
{<var>s1p</var>, <var>s1n</var>}.
</p>
<dl>
<dt id="index-mpn_005fadd_005fn">Function: <em>mp_limb_t</em> <strong>mpn_add_n</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Add {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>, <var>n</var>}, and write the <var>n</var>
least significant limbs of the result to <var>rp</var>.  Return carry, either 0 or
1.
</p>
<p>This is the lowest-level function for addition.  It is the preferred function
for addition, since it is written in assembly for most CPUs.  For addition of
a variable to itself (i.e., <var>s1p</var> equals <var>s2p</var>) use <code>mpn_lshift</code>
with a count of 1 for optimal speed.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fadd_005f1">Function: <em>mp_limb_t</em> <strong>mpn_add_1</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)</em></dt>
<dd><p>Add {<var>s1p</var>, <var>n</var>} and <var>s2limb</var>, and write the <var>n</var> least
significant limbs of the result to <var>rp</var>.  Return carry, either 0 or 1.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fadd">Function: <em>mp_limb_t</em> <strong>mpn_add</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)</em></dt>
<dd><p>Add {<var>s1p</var>, <var>s1n</var>} and {<var>s2p</var>, <var>s2n</var>}, and write the
<var>s1n</var> least significant limbs of the result to <var>rp</var>.  Return carry,
either 0 or 1.
</p>
<p>This function requires that <var>s1n</var> is greater than or equal to <var>s2n</var>.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsub_005fn">Function: <em>mp_limb_t</em> <strong>mpn_sub_n</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Subtract {<var>s2p</var>, <var>n</var>} from {<var>s1p</var>, <var>n</var>}, and write the
<var>n</var> least significant limbs of the result to <var>rp</var>.  Return borrow,
either 0 or 1.
</p>
<p>This is the lowest-level function for subtraction.  It is the preferred
function for subtraction, since it is written in assembly for most CPUs.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsub_005f1">Function: <em>mp_limb_t</em> <strong>mpn_sub_1</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)</em></dt>
<dd><p>Subtract <var>s2limb</var> from {<var>s1p</var>, <var>n</var>}, and write the <var>n</var> least
significant limbs of the result to <var>rp</var>.  Return borrow, either 0 or 1.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsub">Function: <em>mp_limb_t</em> <strong>mpn_sub</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)</em></dt>
<dd><p>Subtract {<var>s2p</var>, <var>s2n</var>} from {<var>s1p</var>, <var>s1n</var>}, and write the
<var>s1n</var> least significant limbs of the result to <var>rp</var>.  Return borrow,
either 0 or 1.
</p>
<p>This function requires that <var>s1n</var> is greater than or equal to
<var>s2n</var>.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fneg">Function: <em>mp_limb_t</em> <strong>mpn_neg</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>sp</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Perform the negation of {<var>sp</var>, <var>n</var>}, and write the result to
{<var>rp</var>, <var>n</var>}.  This is equivalent to calling <code>mpn_sub_n</code> with a
<var>n</var>-limb zero minuend and passing {<var>sp</var>, <var>n</var>} as subtrahend.
Return borrow, either 0 or 1.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fmul_005fn">Function: <em>void</em> <strong>mpn_mul_n</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Multiply {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>, <var>n</var>}, and write the
2*<var>n</var>-limb result to <var>rp</var>.
</p>
<p>The destination has to have space for 2*<var>n</var> limbs, even if the product&rsquo;s
most significant limb is zero.  No overlap is permitted between the
destination and either source.
</p>
<p>If the two input operands are the same, use <code>mpn_sqr</code>.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fmul">Function: <em>mp_limb_t</em> <strong>mpn_mul</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)</em></dt>
<dd><p>Multiply {<var>s1p</var>, <var>s1n</var>} and {<var>s2p</var>, <var>s2n</var>}, and write the
(<var>s1n</var>+<var>s2n</var>)-limb result to <var>rp</var>.  Return the most significant
limb of the result.
</p>
<p>The destination has to have space for <var>s1n</var> + <var>s2n</var> limbs, even if the
product&rsquo;s most significant limb is zero.  No overlap is permitted between the
destination and either source.
</p>
<p>This function requires that <var>s1n</var> is greater than or equal to <var>s2n</var>.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsqr">Function: <em>void</em> <strong>mpn_sqr</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Compute the square of {<var>s1p</var>, <var>n</var>} and write the 2*<var>n</var>-limb
result to <var>rp</var>.
</p>
<p>The destination has to have space for 2<var>n</var> limbs, even if the result&rsquo;s
most significant limb is zero.  No overlap is permitted between the
destination and the source.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fmul_005f1">Function: <em>mp_limb_t</em> <strong>mpn_mul_1</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)</em></dt>
<dd><p>Multiply {<var>s1p</var>, <var>n</var>} by <var>s2limb</var>, and write the <var>n</var> least
significant limbs of the product to <var>rp</var>.  Return the most significant
limb of the product.  {<var>s1p</var>, <var>n</var>} and {<var>rp</var>, <var>n</var>} are
allowed to overlap provided <em><var>rp</var> &lt;= <var>s1p</var></em>.
</p>
<p>This is a low-level function that is a building block for general
multiplication as well as other operations in GMP.  It is written in assembly
for most CPUs.
</p>
<p>Don&rsquo;t call this function if <var>s2limb</var> is a power of 2; use <code>mpn_lshift</code>
with a count equal to the logarithm of <var>s2limb</var> instead, for optimal speed.
</p></dd></dl>
<dl>
<dt id="index-mpn_005faddmul_005f1">Function: <em>mp_limb_t</em> <strong>mpn_addmul_1</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)</em></dt>
<dd><p>Multiply {<var>s1p</var>, <var>n</var>} and <var>s2limb</var>, and add the <var>n</var> least
significant limbs of the product to {<var>rp</var>, <var>n</var>} and write the result
to <var>rp</var>.  Return the most significant limb of the product, plus carry-out
from the addition.  {<var>s1p</var>, <var>n</var>} and {<var>rp</var>, <var>n</var>} are
allowed to overlap provided <em><var>rp</var> &lt;= <var>s1p</var></em>.
</p>
<p>This is a low-level function that is a building block for general
multiplication as well as other operations in GMP.  It is written in assembly
for most CPUs.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsubmul_005f1">Function: <em>mp_limb_t</em> <strong>mpn_submul_1</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)</em></dt>
<dd><p>Multiply {<var>s1p</var>, <var>n</var>} and <var>s2limb</var>, and subtract the <var>n</var>
least significant limbs of the product from {<var>rp</var>, <var>n</var>} and write the
result to <var>rp</var>.  Return the most significant limb of the product, plus
borrow-out from the subtraction.  {<var>s1p</var>, <var>n</var>} and {<var>rp</var>,
<var>n</var>} are allowed to overlap provided <em><var>rp</var> &lt;= <var>s1p</var></em>.
</p>
<p>This is a low-level function that is a building block for general
multiplication and division as well as other operations in GMP.  It is written
in assembly for most CPUs.
</p></dd></dl>
<dl>
<dt id="index-mpn_005ftdiv_005fqr">Function: <em>void</em> <strong>mpn_tdiv_qr</strong> <em>(mp_limb_t *<var>qp</var>, mp_limb_t *<var>rp</var>, mp_size_t <var>qxn</var>, const mp_limb_t *<var>np</var>, mp_size_t <var>nn</var>, const mp_limb_t *<var>dp</var>, mp_size_t <var>dn</var>)</em></dt>
<dd><p>Divide {<var>np</var>, <var>nn</var>} by {<var>dp</var>, <var>dn</var>} and put the quotient
at {<var>qp</var>, <var>nn</var>-<var>dn</var>+1} and the remainder at {<var>rp</var>,
<var>dn</var>}.  The quotient is rounded towards 0.
</p>
<p>No overlap is permitted between arguments, except that <var>np</var> might equal
<var>rp</var>.  The dividend size <var>nn</var> must be greater than or equal to divisor
size <var>dn</var>.  The most significant limb of the divisor must be non-zero.  The
<var>qxn</var> operand must be zero.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fdivrem">Function: <em>mp_limb_t</em> <strong>mpn_divrem</strong> <em>(mp_limb_t *<var>r1p</var>, mp_size_t <var>qxn</var>, mp_limb_t *<var>rs2p</var>, mp_size_t <var>rs2n</var>, const mp_limb_t *<var>s3p</var>, mp_size_t <var>s3n</var>)</em></dt>
<dd><p>[This function is obsolete.  Please call <code>mpn_tdiv_qr</code> instead for best
performance.]
</p>
<p>Divide {<var>rs2p</var>, <var>rs2n</var>} by {<var>s3p</var>, <var>s3n</var>}, and write the
quotient at <var>r1p</var>, with the exception of the most significant limb, which
is returned.  The remainder replaces the dividend at <var>rs2p</var>; it will be
<var>s3n</var> limbs long (i.e., as many limbs as the divisor).
</p>
<p>In addition to an integer quotient, <var>qxn</var> fraction limbs are developed, and
stored after the integral limbs.  For most usages, <var>qxn</var> will be zero.
</p>
<p>It is required that <var>rs2n</var> is greater than or equal to <var>s3n</var>.  It is
required that the most significant bit of the divisor is set.
</p>
<p>If the quotient is not needed, pass <var>rs2p</var> + <var>s3n</var> as <var>r1p</var>.  Aside
from that special case, no overlap between arguments is permitted.
</p>
<p>Return the most significant limb of the quotient, either 0 or 1.
</p>
<p>The area at <var>r1p</var> needs to be <var>rs2n</var> - <var>s3n</var> + <var>qxn</var>
limbs large.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fdivrem_005f1">Function: <em>mp_limb_t</em> <strong>mpn_divrem_1</strong> <em>(mp_limb_t *<var>r1p</var>, mp_size_t <var>qxn</var>, <span class="nolinebreak">mp_limb_t</span>&nbsp;*<var>s2p</var><!-- /@w -->, mp_size_t <var>s2n</var>, mp_limb_t <var>s3limb</var>)</em></dt>
<dt id="index-mpn_005fdivmod_005f1">Macro: <em>mp_limb_t</em> <strong>mpn_divmod_1</strong> <em>(mp_limb_t *<var>r1p</var>, mp_limb_t *<var>s2p</var>, <span class="nolinebreak">mp_size_t</span>&nbsp;<var>s2n</var><!-- /@w -->, <span class="nolinebreak">mp_limb_t</span>&nbsp;<var>s3limb</var><!-- /@w -->)</em></dt>
<dd><p>Divide {<var>s2p</var>, <var>s2n</var>} by <var>s3limb</var>, and write the quotient at
<var>r1p</var>.  Return the remainder.
</p>
<p>The integer quotient is written to {<var>r1p</var>+<var>qxn</var>, <var>s2n</var>} and in
addition <var>qxn</var> fraction limbs are developed and written to {<var>r1p</var>,
<var>qxn</var>}.  Either or both <var>s2n</var> and <var>qxn</var> can be zero.  For most
usages, <var>qxn</var> will be zero.
</p>
<p><code>mpn_divmod_1</code> exists for upward source compatibility and is simply a
macro calling <code>mpn_divrem_1</code> with a <var>qxn</var> of 0.
</p>
<p>The areas at <var>r1p</var> and <var>s2p</var> have to be identical or completely
separate, not partially overlapping.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fdivmod">Function: <em>mp_limb_t</em> <strong>mpn_divmod</strong> <em>(mp_limb_t *<var>r1p</var>, mp_limb_t *<var>rs2p</var>, mp_size_t <var>rs2n</var>, const mp_limb_t *<var>s3p</var>, mp_size_t <var>s3n</var>)</em></dt>
<dd><p>[This function is obsolete.  Please call <code>mpn_tdiv_qr</code> instead for best
performance.]
</p></dd></dl>
<dl>
<dt id="index-mpn_005fdivexact_005f1">Function: <em>void</em> <strong>mpn_divexact_1</strong> <em>(mp_limb_t * <var>rp</var>, const mp_limb_t * <var>sp</var>, mp_size_t <var>n</var>, mp_limb_t <var>d</var>)</em></dt>
<dd><p>Divide {<var>sp</var>, <var>n</var>} by <var>d</var>, expecting it to divide exactly, and
writing the result to {<var>rp</var>, <var>n</var>}. If <var>d</var> doesn&rsquo;t divide
exactly, the value written to {<var>rp</var>, <var>n</var>} is undefined. The areas at
<var>rp</var> and <var>sp</var> have to be identical or completely separate, not
partially overlapping.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fdivexact_005fby3">Macro: <em>mp_limb_t</em> <strong>mpn_divexact_by3</strong> <em>(mp_limb_t *<var>rp</var>, mp_limb_t *<var>sp</var>, <span class="nolinebreak">mp_size_t</span>&nbsp;<var>n</var><!-- /@w -->)</em></dt>
<dt id="index-mpn_005fdivexact_005fby3c">Function: <em>mp_limb_t</em> <strong>mpn_divexact_by3c</strong> <em>(mp_limb_t *<var>rp</var>, mp_limb_t *<var>sp</var>, <span class="nolinebreak">mp_size_t</span>&nbsp;<var>n</var><!-- /@w -->, mp_limb_t <var>carry</var>)</em></dt>
<dd><p>Divide {<var>sp</var>, <var>n</var>} by 3, expecting it to divide exactly, and writing
the result to {<var>rp</var>, <var>n</var>}.  If 3 divides exactly, the return value is
zero and the result is the quotient.  If not, the return value is non-zero and
the result won&rsquo;t be anything useful.
</p>
<p><code>mpn_divexact_by3c</code> takes an initial carry parameter, which can be the
return value from a previous call, so a large calculation can be done piece by
piece from low to high.  <code>mpn_divexact_by3</code> is simply a macro calling
<code>mpn_divexact_by3c</code> with a 0 carry parameter.
</p>
<p>These routines use a multiply-by-inverse and will be faster than
<code>mpn_divrem_1</code> on CPUs with fast multiplication but slow division.
</p>
<p>The source <em>a</em>, result <em>q</em>, size <em>n</em>, initial carry <em>i</em>,
and return value <em>c</em> satisfy <em>c*b^n + a-i = 3*q</em>, where
<em>b=2^GMP_NUMB_BITS</em>.  The
return <em>c</em> is always 0, 1 or 2, and the initial carry <em>i</em> must also
be 0, 1 or 2 (these are both borrows really).  When <em>c=0</em> clearly
<em>q=(a-i)/3</em>.  When <em>c!=0</em>, the remainder <em>(a-i) mod
3</em> is given by <em>3-c</em>, because <em>b &equiv; 1 mod 3</em> (when
<code>mp_bits_per_limb</code> is even, which is always so currently).
</p></dd></dl>
<dl>
<dt id="index-mpn_005fmod_005f1">Function: <em>mp_limb_t</em> <strong>mpn_mod_1</strong> <em>(const mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, mp_limb_t <var>s2limb</var>)</em></dt>
<dd><p>Divide {<var>s1p</var>, <var>s1n</var>} by <var>s2limb</var>, and return the remainder.
<var>s1n</var> can be zero.
</p></dd></dl>
<dl>
<dt id="index-mpn_005flshift">Function: <em>mp_limb_t</em> <strong>mpn_lshift</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>sp</var>, mp_size_t <var>n</var>, unsigned int <var>count</var>)</em></dt>
<dd><p>Shift {<var>sp</var>, <var>n</var>} left by <var>count</var> bits, and write the result to
{<var>rp</var>, <var>n</var>}.  The bits shifted out at the left are returned in the
least significant <var>count</var> bits of the return value (the rest of the return
value is zero).
</p>
<p><var>count</var> must be in the range 1 to <code>mp_bits_per_limb</code>-1.  The
regions {<var>sp</var>, <var>n</var>} and {<var>rp</var>, <var>n</var>} may overlap, provided
<em><var>rp</var> &gt;= <var>sp</var></em>.
</p>
<p>This function is written in assembly for most CPUs.
</p></dd></dl>
<dl>
<dt id="index-mpn_005frshift">Function: <em>mp_limb_t</em> <strong>mpn_rshift</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>sp</var>, mp_size_t <var>n</var>, unsigned int <var>count</var>)</em></dt>
<dd><p>Shift {<var>sp</var>, <var>n</var>} right by <var>count</var> bits, and write the result to
{<var>rp</var>, <var>n</var>}.  The bits shifted out at the right are returned in the
most significant <var>count</var> bits of the return value (the rest of the return
value is zero).
</p>
<p><var>count</var> must be in the range 1 to <code>mp_bits_per_limb</code>-1.  The
regions {<var>sp</var>, <var>n</var>} and {<var>rp</var>, <var>n</var>} may overlap, provided
<em><var>rp</var> &lt;= <var>sp</var></em>.
</p>
<p>This function is written in assembly for most CPUs.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fcmp">Function: <em>int</em> <strong>mpn_cmp</strong> <em>(const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Compare {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>, <var>n</var>} and return a
positive value if <em><var>s1</var> &gt; <var>s2</var></em>, 0 if they are equal, or a
negative value if <em><var>s1</var> &lt; <var>s2</var></em>.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fzero_005fp">Function: <em>int</em> <strong>mpn_zero_p</strong> <em>(const mp_limb_t *<var>sp</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Test {<var>sp</var>, <var>n</var>} and return 1 if the operand is zero, 0 otherwise.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fgcd">Function: <em>mp_size_t</em> <strong>mpn_gcd</strong> <em>(mp_limb_t *<var>rp</var>, mp_limb_t *<var>xp</var>, mp_size_t <var>xn</var>, mp_limb_t *<var>yp</var>, mp_size_t <var>yn</var>)</em></dt>
<dd><p>Set {<var>rp</var>, <var>retval</var>} to the greatest common divisor of {<var>xp</var>,
<var>xn</var>} and {<var>yp</var>, <var>yn</var>}.  The result can be up to <var>yn</var> limbs,
the return value is the actual number produced.  Both source operands are
destroyed.
</p>
<p>It is required that <em><var>xn</var> &gt;= <var>yn</var> &gt; 0</em>, the most significant
limb of {<var>yp</var>, <var>yn</var>} must be non-zero, and at least one of
the two operands must be odd.  No overlap is permitted
between {<var>xp</var>, <var>xn</var>} and {<var>yp</var>, <var>yn</var>}.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fgcd_005f1">Function: <em>mp_limb_t</em> <strong>mpn_gcd_1</strong> <em>(const mp_limb_t *<var>xp</var>, mp_size_t <var>xn</var>, mp_limb_t <var>ylimb</var>)</em></dt>
<dd><p>Return the greatest common divisor of {<var>xp</var>, <var>xn</var>} and <var>ylimb</var>.
Both operands must be non-zero.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fgcdext">Function: <em>mp_size_t</em> <strong>mpn_gcdext</strong> <em>(mp_limb_t *<var>gp</var>, mp_limb_t *<var>sp</var>, mp_size_t *<var>sn</var>, mp_limb_t *<var>up</var>, mp_size_t <var>un</var>, mp_limb_t *<var>vp</var>, mp_size_t <var>vn</var>)</em></dt>
<dd><p>Let <em><var>U</var></em> be defined by {<var>up</var>, <var>un</var>} and let <em><var>V</var></em> be
defined by {<var>vp</var>, <var>vn</var>}.
</p>
<p>Compute the greatest common divisor <em>G</em> of <em>U</em> and <em>V</em>.  Compute
a cofactor <em>S</em> such that <em>G = US + VT</em>.  The second cofactor <var>T</var>
is not computed but can easily be obtained from <em>(<var>G</var> -
<var>U</var>*<var>S</var>) / <var>V</var></em> (the division will be exact).  It is required that
<em><var>un</var> &gt;= <var>vn</var> &gt; 0</em>, and the most significant
limb of {<var>vp</var>, <var>vn</var>} must be non-zero.
</p>
<p><em>S</em> satisfies <em>S = 1</em> or <em>abs(S) &lt; V / (2 G)</em>. <em>S =
0</em> if and only if <em>V</em> divides <em>U</em> (i.e., <em>G = V</em>).
</p>
<p>Store <em>G</em> at <var>gp</var> and let the return value define its limb count.
Store <em>S</em> at <var>sp</var> and let |*<var>sn</var>| define its limb count.  <em>S</em>
can be negative; when this happens *<var>sn</var> will be negative.  The area at
<var>gp</var> should have room for <var>vn</var> limbs and the area at <var>sp</var> should
have room for <em><var>vn</var>+1</em> limbs.
</p>
<p>Both source operands are destroyed.
</p>
<p>Compatibility notes: GMP 4.3.0 and 4.3.1 defined <em>S</em> less strictly.
Earlier as well as later GMP releases define <em>S</em> as described here.
GMP releases before GMP 4.3.0 required additional space for both input and output
areas. More precisely, the areas {<var>up</var>, <em><var>un</var>+1</em>} and
{<var>vp</var>, <em><var>vn</var>+1</em>} were destroyed (i.e. the operands plus an
extra limb past the end of each), and the areas pointed to by <var>gp</var> and
<var>sp</var> should each have room for <em><var>un</var>+1</em> limbs.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsqrtrem">Function: <em>mp_size_t</em> <strong>mpn_sqrtrem</strong> <em>(mp_limb_t *<var>r1p</var>, mp_limb_t *<var>r2p</var>, const mp_limb_t *<var>sp</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Compute the square root of {<var>sp</var>, <var>n</var>} and put the result at
{<var>r1p</var>, <em>ceil(<var>n</var>/2)</em>} and the remainder at {<var>r2p</var>,
<var>retval</var>}.  <var>r2p</var> needs space for <var>n</var> limbs, but the return value
indicates how many are produced.
</p>
<p>The most significant limb of {<var>sp</var>, <var>n</var>} must be non-zero.  The
areas {<var>r1p</var>, <em>ceil(<var>n</var>/2)</em>} and {<var>sp</var>, <var>n</var>} must
be completely separate.  The areas {<var>r2p</var>, <var>n</var>} and {<var>sp</var>,
<var>n</var>} must be either identical or completely separate.
</p>
<p>If the remainder is not wanted then <var>r2p</var> can be <code>NULL</code>, and in this
case the return value is zero or non-zero according to whether the remainder
would have been zero or non-zero.
</p>
<p>A return value of zero indicates a perfect square.  See also
<code>mpn_perfect_square_p</code>.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsizeinbase">Function: <em>size_t</em> <strong>mpn_sizeinbase</strong> <em>(const mp_limb_t *<var>xp</var>, mp_size_t <var>n</var>, int <var>base</var>)</em></dt>
<dd><p>Return the size of {<var>xp</var>,<var>n</var>} measured in number of digits in the
given <var>base</var>.  <var>base</var> can vary from 2 to 62.  Requires <em><var>n</var> &gt; 0</em>
and <em><var>xp</var>[<var>n</var>-1] &gt; 0</em>.  The result will be either exact or
1 too big.  If <var>base</var> is a power of 2, the result is always exact.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fget_005fstr">Function: <em>mp_size_t</em> <strong>mpn_get_str</strong> <em>(unsigned char *<var>str</var>, int <var>base</var>, mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>)</em></dt>
<dd><p>Convert {<var>s1p</var>, <var>s1n</var>} to a raw unsigned char array at <var>str</var> in
base <var>base</var>, and return the number of characters produced.  There may be
leading zeros in the string.  The string is not in ASCII; to convert it to
printable format, add the ASCII codes for &lsquo;<samp>0</samp>&rsquo; or &lsquo;<samp>A</samp>&rsquo;, depending on
the base and range.  <var>base</var> can vary from 2 to 256.
</p>
<p>The most significant limb of the input {<var>s1p</var>, <var>s1n</var>} must be
non-zero.  The input {<var>s1p</var>, <var>s1n</var>} is clobbered, except when
<var>base</var> is a power of 2, in which case it&rsquo;s unchanged.
</p>
<p>The area at <var>str</var> has to have space for the largest possible number
represented by a <var>s1n</var> long limb array, plus one extra character.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fset_005fstr">Function: <em>mp_size_t</em> <strong>mpn_set_str</strong> <em>(mp_limb_t *<var>rp</var>, const unsigned char *<var>str</var>, size_t <var>strsize</var>, int <var>base</var>)</em></dt>
<dd><p>Convert bytes {<var>str</var>,<var>strsize</var>} in the given <var>base</var> to limbs at
<var>rp</var>.
</p>
<p><em><var>str</var>[0]</em> is the most significant input byte and
<em><var>str</var>[<var>strsize</var>-1]</em> is the least significant input byte.  Each
byte should be a value in the range 0 to <em><var>base</var>-1</em>, not an ASCII
character.  <var>base</var> can vary from 2 to 256.
</p>
<p>The converted value is {<var>rp</var>,<var>rn</var>} where <var>rn</var> is the return
value.  If the most significant input byte <em><var>str</var>[0]</em> is non-zero,
then <em><var>rp</var>[<var>rn</var>-1]</em> will be non-zero, else
<em><var>rp</var>[<var>rn</var>-1]</em> and some number of subsequent limbs may be zero.
</p>
<p>The area at <var>rp</var> has to have space for the largest possible number with
<var>strsize</var> digits in the chosen base, plus one extra limb.
</p>
<p>The input must have at least one byte, and no overlap is permitted between
{<var>str</var>,<var>strsize</var>} and the result at <var>rp</var>.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fscan0">Function: <em>mp_bitcnt_t</em> <strong>mpn_scan0</strong> <em>(const mp_limb_t *<var>s1p</var>, mp_bitcnt_t <var>bit</var>)</em></dt>
<dd><p>Scan <var>s1p</var> from bit position <var>bit</var> for the next clear bit.
</p>
<p>It is required that there be a clear bit within the area at <var>s1p</var> at or
beyond bit position <var>bit</var>, so that the function has something to return.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fscan1">Function: <em>mp_bitcnt_t</em> <strong>mpn_scan1</strong> <em>(const mp_limb_t *<var>s1p</var>, mp_bitcnt_t <var>bit</var>)</em></dt>
<dd><p>Scan <var>s1p</var> from bit position <var>bit</var> for the next set bit.
</p>
<p>It is required that there be a set bit within the area at <var>s1p</var> at or
beyond bit position <var>bit</var>, so that the function has something to return.
</p></dd></dl>
<dl>
<dt id="index-mpn_005frandom">Function: <em>void</em> <strong>mpn_random</strong> <em>(mp_limb_t *<var>r1p</var>, mp_size_t <var>r1n</var>)</em></dt>
<dt id="index-mpn_005frandom2">Function: <em>void</em> <strong>mpn_random2</strong> <em>(mp_limb_t *<var>r1p</var>, mp_size_t <var>r1n</var>)</em></dt>
<dd><p>Generate a random number of length <var>r1n</var> and store it at <var>r1p</var>.  The
most significant limb is always non-zero.  <code>mpn_random</code> generates
uniformly distributed limb data, <code>mpn_random2</code> generates long strings of
zeros and ones in the binary representation.
</p>
<p><code>mpn_random2</code> is intended for testing the correctness of the <code>mpn</code>
routines.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fpopcount">Function: <em>mp_bitcnt_t</em> <strong>mpn_popcount</strong> <em>(const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Count the number of set bits in {<var>s1p</var>, <var>n</var>}.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fhamdist">Function: <em>mp_bitcnt_t</em> <strong>mpn_hamdist</strong> <em>(const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Compute the hamming distance between {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>,
<var>n</var>}, which is the number of bit positions where the two operands have
different bit values.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fperfect_005fsquare_005fp">Function: <em>int</em> <strong>mpn_perfect_square_p</strong> <em>(const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Return non-zero iff {<var>s1p</var>, <var>n</var>} is a perfect square.
The most significant limb of the input {<var>s1p</var>, <var>n</var>} must be
non-zero.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fand_005fn">Function: <em>void</em> <strong>mpn_and_n</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Perform the bitwise logical and of {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>,
<var>n</var>}, and write the result to {<var>rp</var>, <var>n</var>}.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fior_005fn">Function: <em>void</em> <strong>mpn_ior_n</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Perform the bitwise logical inclusive or of {<var>s1p</var>, <var>n</var>} and
{<var>s2p</var>, <var>n</var>}, and write the result to {<var>rp</var>, <var>n</var>}.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fxor_005fn">Function: <em>void</em> <strong>mpn_xor_n</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Perform the bitwise logical exclusive or of {<var>s1p</var>, <var>n</var>} and
{<var>s2p</var>, <var>n</var>}, and write the result to {<var>rp</var>, <var>n</var>}.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fandn_005fn">Function: <em>void</em> <strong>mpn_andn_n</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Perform the bitwise logical and of {<var>s1p</var>, <var>n</var>} and the bitwise
complement of {<var>s2p</var>, <var>n</var>}, and write the result to {<var>rp</var>, <var>n</var>}.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fiorn_005fn">Function: <em>void</em> <strong>mpn_iorn_n</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Perform the bitwise logical inclusive or of {<var>s1p</var>, <var>n</var>} and the bitwise
complement of {<var>s2p</var>, <var>n</var>}, and write the result to {<var>rp</var>, <var>n</var>}.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fnand_005fn">Function: <em>void</em> <strong>mpn_nand_n</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Perform the bitwise logical and of {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>,
<var>n</var>}, and write the bitwise complement of the result to {<var>rp</var>, <var>n</var>}.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fnior_005fn">Function: <em>void</em> <strong>mpn_nior_n</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Perform the bitwise logical inclusive or of {<var>s1p</var>, <var>n</var>} and
{<var>s2p</var>, <var>n</var>}, and write the bitwise complement of the result to
{<var>rp</var>, <var>n</var>}.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fxnor_005fn">Function: <em>void</em> <strong>mpn_xnor_n</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Perform the bitwise logical exclusive or of {<var>s1p</var>, <var>n</var>} and
{<var>s2p</var>, <var>n</var>}, and write the bitwise complement of the result to
{<var>rp</var>, <var>n</var>}.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fcom">Function: <em>void</em> <strong>mpn_com</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>sp</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Perform the bitwise complement of {<var>sp</var>, <var>n</var>}, and write the result
to {<var>rp</var>, <var>n</var>}.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fcopyi">Function: <em>void</em> <strong>mpn_copyi</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Copy from {<var>s1p</var>, <var>n</var>} to {<var>rp</var>, <var>n</var>}, increasingly.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fcopyd">Function: <em>void</em> <strong>mpn_copyd</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Copy from {<var>s1p</var>, <var>n</var>} to {<var>rp</var>, <var>n</var>}, decreasingly.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fzero">Function: <em>void</em> <strong>mpn_zero</strong> <em>(mp_limb_t *<var>rp</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>Zero {<var>rp</var>, <var>n</var>}.
</p></dd></dl>
<br>
<span id="Low_002dlevel-functions-for-cryptography"></span><h3 class="section">8.1 Low-level functions for cryptography</h3>
<span id="index-Low_002dlevel-functions-for-cryptography"></span>
<span id="index-Cryptography-functions_002c-low_002dlevel"></span>
<p>The functions prefixed with <code>mpn_sec_</code> and <code>mpn_cnd_</code> are designed to
perform the exact same low-level operations and have the same cache access
patterns for any two same-size arguments, assuming that function arguments are
placed at the same position and that the machine state is identical upon
function entry.  These functions are intended for cryptographic purposes, where
resilience to side-channel attacks is desired.
</p>
<p>These functions are less efficient than their &ldquo;leaky&rdquo; counterparts; their
performance for operands of the sizes typically used for cryptographic
applications is between 15% and 100% worse.  For larger operands, these
functions might be inadequate, since they rely on asymptotically elementary
algorithms.
</p>
<p>These functions do not make any explicit allocations.  Those of these functions
that need scratch space accept a scratch space operand.  This convention allows
callers to keep sensitive data in designated memory areas.  Note however that
compilers may choose to spill scalar values used within these functions to
their stack frame and that such scalars may contain sensitive data.
</p>
<p>In addition to these specially crafted functions, the following <code>mpn</code>
functions are naturally side-channel resistant: <code>mpn_add_n</code>,
<code>mpn_sub_n</code>, <code>mpn_lshift</code>, <code>mpn_rshift</code>, <code>mpn_zero</code>,
<code>mpn_copyi</code>, <code>mpn_copyd</code>, <code>mpn_com</code>, and the logical function
(<code>mpn_and_n</code>, etc).
</p>
<p>There are some exceptions from the side-channel resilience: (1) Some assembly
implementations of <code>mpn_lshift</code> identify shift-by-one as a special case.
This is a problem iff the shift count is a function of sensitive data.  (2)
Alpha ev6 and Pentium4 using 64-bit limbs have leaky <code>mpn_add_n</code> and
<code>mpn_sub_n</code>.  (3) Alpha ev6 has a leaky <code>mpn_mul_1</code> which also makes
<code>mpn_sec_mul</code> on those systems unsafe.
</p>
<dl>
<dt id="index-mpn_005fcnd_005fadd_005fn">Function: <em>mp_limb_t</em> <strong>mpn_cnd_add_n</strong> <em>(mp_limb_t <var>cnd</var>, mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dt id="index-mpn_005fcnd_005fsub_005fn">Function: <em>mp_limb_t</em> <strong>mpn_cnd_sub_n</strong> <em>(mp_limb_t <var>cnd</var>, mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>These functions do conditional addition and subtraction.  If <var>cnd</var> is
non-zero, they produce the same result as a regular <code>mpn_add_n</code> or
<code>mpn_sub_n</code>, and if <var>cnd</var> is zero, they copy {<var>s1p</var>,<var>n</var>} to
the result area and return zero.  The functions are designed to have timing and
memory access patterns depending only on size and location of the data areas,
but independent of the condition <var>cnd</var>.  Like for <code>mpn_add_n</code> and
<code>mpn_sub_n</code>, on most machines, the timing will also be independent of the
actual limb values.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsec_005fadd_005f1">Function: <em>mp_limb_t</em> <strong>mpn_sec_add_1</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>ap</var>, mp_size_t <var>n</var>, mp_limb_t <var>b</var>, mp_limb_t *<var>tp</var>)</em></dt>
<dt id="index-mpn_005fsec_005fsub_005f1">Function: <em>mp_limb_t</em> <strong>mpn_sec_sub_1</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>ap</var>, mp_size_t <var>n</var>, mp_limb_t <var>b</var>, mp_limb_t *<var>tp</var>)</em></dt>
<dd><p>Set <var>R</var> to <var>A</var> + <var>b</var> or <var>A</var> - <var>b</var>, respectively, where
<var>R</var> = {<var>rp</var>,<var>n</var>}, <var>A</var> = {<var>ap</var>,<var>n</var>}, and <var>b</var> is
a single limb. Returns carry.
</p>
<p>These functions take <em>O(N)</em> time, unlike the leaky functions
<code>mpn_add_1</code> which are <em>O(1)</em> on average. They require scratch space
of <code>mpn_sec_add_1_itch(<var>n</var>)</code> and <code>mpn_sec_sub_1_itch(<var>n</var>)</code>
limbs, respectively, to be passed in the <var>tp</var> parameter. The scratch space
requirements are guaranteed to be at most <var>n</var> limbs, and increase
monotonously in the operand size.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fcnd_005fswap">Function: <em>void</em> <strong>mpn_cnd_swap</strong> <em>(mp_limb_t <var>cnd</var>, volatile mp_limb_t *<var>ap</var>, volatile mp_limb_t *<var>bp</var>, mp_size_t <var>n</var>)</em></dt>
<dd><p>If <var>cnd</var> is non-zero, swaps the contents of the areas {<var>ap</var>,<var>n</var>}
and {<var>bp</var>,<var>n</var>}. Otherwise, the areas are left unmodified.
Implemented using logical operations on the limbs, with the same memory
accesses independent of the value of <var>cnd</var>.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsec_005fmul">Function: <em>void</em> <strong>mpn_sec_mul</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>ap</var>, mp_size_t <var>an</var>, const mp_limb_t *<var>bp</var>, mp_size_t <var>bn</var>, mp_limb_t *<var>tp</var>)</em></dt>
<dt id="index-mpn_005fsec_005fmul_005fitch">Function: <em>mp_size_t</em> <strong>mpn_sec_mul_itch</strong> <em>(mp_size_t <var>an</var>, mp_size_t <var>bn</var>)</em></dt>
<dd><p>Set <var>R</var> to <em>A * B</em>, where <var>A</var> = {<var>ap</var>,<var>an</var>},
<var>B</var> = {<var>bp</var>,<var>bn</var>}, and <var>R</var> =
{<var>rp</var>,<em><var>an</var>+<var>bn</var></em>}.
</p>
<p>It is required that <em><var>an</var> &gt;= <var>bn</var> &gt; 0</em>.
</p>
<p>No overlapping between <var>R</var> and the input operands is allowed.  For
<em><var>A</var> = <var>B</var></em>, use <code>mpn_sec_sqr</code> for optimal performance.
</p>
<p>This function requires scratch space of <code>mpn_sec_mul_itch(<var>an</var>,
<var>bn</var>)</code> limbs to be passed in the <var>tp</var> parameter.  The scratch space
requirements are guaranteed to increase monotonously in the operand sizes.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsec_005fsqr">Function: <em>void</em> <strong>mpn_sec_sqr</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>ap</var>, mp_size_t <var>an</var>, mp_limb_t *<var>tp</var>)</em></dt>
<dt id="index-mpn_005fsec_005fsqr_005fitch">Function: <em>mp_size_t</em> <strong>mpn_sec_sqr_itch</strong> <em>(mp_size_t <var>an</var>)</em></dt>
<dd><p>Set <var>R</var> to <em>A^2</em>, where <var>A</var> = {<var>ap</var>,<var>an</var>}, and <var>R</var> =
{<var>rp</var>,<em>2<var>an</var></em>}.
</p>
<p>It is required that <em><var>an</var> &gt; 0</em>.
</p>
<p>No overlapping between <var>R</var> and the input operands is allowed.
</p>
<p>This function requires scratch space of <code>mpn_sec_sqr_itch(<var>an</var>)</code> limbs
to be passed in the <var>tp</var> parameter.  The scratch space requirements are
guaranteed to increase monotonously in the operand size.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsec_005fpowm">Function: <em>void</em> <strong>mpn_sec_powm</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>bp</var>, mp_size_t <var>bn</var>, const mp_limb_t *<var>ep</var>, mp_bitcnt_t <var>enb</var>,  const mp_limb_t *<var>mp</var>, mp_size_t <var>n</var>, mp_limb_t *<var>tp</var>)</em></dt>
<dt id="index-mpn_005fsec_005fpowm_005fitch">Function: <em>mp_size_t</em> <strong>mpn_sec_powm_itch</strong> <em>(mp_size_t <var>bn</var>, mp_bitcnt_t <var>enb</var>, size_t <var>n</var>)</em></dt>
<dd><p>Set <var>R</var> to <em>(<var>B</var> raised to <var>E</var>) modulo
<var>M</var></em>, where <var>R</var> = {<var>rp</var>,<var>n</var>}, <var>M</var> = {<var>mp</var>,<var>n</var>},
and <var>E</var> = {<var>ep</var>,<em>ceil(<var>enb</var> /
<code>GMP_NUMB_BITS</code>)</em>}.
</p>
<p>It is required that <em><var>B</var> &gt; 0</em>, that <em><var>M</var> &gt; 0</em> is odd, and
that <em><var>E</var> &lt; 2^<var>enb</var></em>, with <em><var>enb</var> &gt; 0</em>.
</p>
<p>No overlapping between <var>R</var> and the input operands is allowed.
</p>
<p>This function requires scratch space of <code>mpn_sec_powm_itch(<var>bn</var>,
<var>enb</var>, <var>n</var>)</code> limbs to be passed in the <var>tp</var> parameter.  The scratch
space requirements are guaranteed to increase monotonously in the operand
sizes.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsec_005ftabselect">Function: <em>void</em> <strong>mpn_sec_tabselect</strong> <em>(mp_limb_t *<var>rp</var>, const mp_limb_t *<var>tab</var>, mp_size_t <var>n</var>, mp_size_t <var>nents</var>, mp_size_t <var>which</var>)</em></dt>
<dd><p>Select entry <var>which</var> from table <var>tab</var>, which has <var>nents</var> entries, each <var>n</var>
limbs.  Store the selected entry at <var>rp</var>.
</p>
<p>This function reads the entire table to avoid side-channel information leaks.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsec_005fdiv_005fqr">Function: <em>mp_limb_t</em> <strong>mpn_sec_div_qr</strong> <em>(mp_limb_t *<var>qp</var>, mp_limb_t *<var>np</var>, mp_size_t <var>nn</var>, const mp_limb_t *<var>dp</var>, mp_size_t <var>dn</var>, mp_limb_t *<var>tp</var>)</em></dt>
<dt id="index-mpn_005fsec_005fdiv_005fqr_005fitch">Function: <em>mp_size_t</em> <strong>mpn_sec_div_qr_itch</strong> <em>(mp_size_t <var>nn</var>, mp_size_t <var>dn</var>)</em></dt>
<dd>
<p>Set <var>Q</var> to <em>the truncated quotient
<var>N</var> / <var>D</var></em> and <var>R</var> to <em><var>N</var> modulo
<var>D</var></em>, where <var>N</var> = {<var>np</var>,<var>nn</var>}, <var>D</var> =
{<var>dp</var>,<var>dn</var>}, <var>Q</var>&rsquo;s most significant limb is the function return
value and the remaining limbs are {<var>qp</var>,<var>nn-dn</var>}, and <var>R</var> =
{<var>np</var>,<var>dn</var>}.
</p>
<p>It is required that <em><var>nn</var> &gt;= <var>dn</var> &gt;= 1</em>, and that
<em><var>dp</var>[<var>dn</var>-1] != 0</em>.  This does not
imply that <em><var>N</var> &gt;= <var>D</var></em> since <var>N</var> might be zero-padded.
</p>
<p>Note the overlapping between <var>N</var> and <var>R</var>.  No other operand overlapping
is allowed.  The entire space occupied by <var>N</var> is overwritten.
</p>
<p>This function requires scratch space of <code>mpn_sec_div_qr_itch(<var>nn</var>,
<var>dn</var>)</code> limbs to be passed in the <var>tp</var> parameter.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsec_005fdiv_005fr">Function: <em>void</em> <strong>mpn_sec_div_r</strong> <em>(mp_limb_t *<var>np</var>, mp_size_t <var>nn</var>, const mp_limb_t *<var>dp</var>, mp_size_t <var>dn</var>, mp_limb_t *<var>tp</var>)</em></dt>
<dt id="index-mpn_005fsec_005fdiv_005fr_005fitch">Function: <em>mp_size_t</em> <strong>mpn_sec_div_r_itch</strong> <em>(mp_size_t <var>nn</var>, mp_size_t <var>dn</var>)</em></dt>
<dd>
<p>Set <var>R</var> to <em><var>N</var> modulo <var>D</var></em>, where <var>N</var>
= {<var>np</var>,<var>nn</var>}, <var>D</var> = {<var>dp</var>,<var>dn</var>}, and <var>R</var> =
{<var>np</var>,<var>dn</var>}.
</p>
<p>It is required that <em><var>nn</var> &gt;= <var>dn</var> &gt;= 1</em>, and that
<em><var>dp</var>[<var>dn</var>-1] != 0</em>.  This does not
imply that <em><var>N</var> &gt;= <var>D</var></em> since <var>N</var> might be zero-padded.
</p>
<p>Note the overlapping between <var>N</var> and <var>R</var>.  No other operand overlapping
is allowed.  The entire space occupied by <var>N</var> is overwritten.
</p>
<p>This function requires scratch space of <code>mpn_sec_div_r_itch(<var>nn</var>,
<var>dn</var>)</code> limbs to be passed in the <var>tp</var> parameter.
</p></dd></dl>
<dl>
<dt id="index-mpn_005fsec_005finvert">Function: <em>int</em> <strong>mpn_sec_invert</strong> <em>(mp_limb_t *<var>rp</var>, mp_limb_t *<var>ap</var>, const mp_limb_t *<var>mp</var>, mp_size_t <var>n</var>, mp_bitcnt_t <var>nbcnt</var>, mp_limb_t *<var>tp</var>)</em></dt>
<dt id="index-mpn_005fsec_005finvert_005fitch">Function: <em>mp_size_t</em> <strong>mpn_sec_invert_itch</strong> <em>(mp_size_t <var>n</var>)</em></dt>
<dd><p>Set <var>R</var> to <em>the inverse of <var>A</var> modulo
<var>M</var></em>, where <var>R</var> = {<var>rp</var>,<var>n</var>}, <var>A</var> = {<var>ap</var>,<var>n</var>},
and <var>M</var> = {<var>mp</var>,<var>n</var>}.  <strong>This function&rsquo;s interface is
preliminary.</strong>
</p>
<p>If an inverse exists, return 1, otherwise return 0 and leave <var>R</var>
undefined. In either case, the input <var>A</var> is destroyed.
</p>
<p>It is required that <var>M</var> is odd, and that <em><var>nbcnt</var> &gt;=
ceil(log(<var>A</var>+1)) + ceil(log(<var>M</var>+1))</em>.  A safe choice is
<em><var>nbcnt</var> = 2
* <var>n</var> * GMP_NUMB_BITS</em>, but a smaller value might improve
performance if <var>M</var> or <var>A</var> are known to have leading zero bits.
</p>
<p>This function requires scratch space of <code>mpn_sec_invert_itch(<var>n</var>)</code>
limbs to be passed in the <var>tp</var> parameter.
</p></dd></dl>
<br>
<span id="Nails"></span><h3 class="section">8.2 Nails</h3>
<span id="index-Nails"></span>
<p><strong>Everything in this section is highly experimental and may disappear or
be subject to incompatible changes in a future version of GMP.</strong>
</p>
<p>Nails are an experimental feature whereby a few bits are left unused at the
top of each <code>mp_limb_t</code>.  This can significantly improve carry handling
on some processors.
</p>
<p>All the <code>mpn</code> functions accepting limb data will expect the nail bits to
be zero on entry, and will return data with the nails similarly all zero.
This applies both to limb vectors and to single limb arguments.
</p>
<p>Nails can be enabled by configuring with &lsquo;<samp>--enable-nails</samp>&rsquo;.  By default
the number of bits will be chosen according to what suits the host processor,
but a particular number can be selected with &lsquo;<samp>--enable-nails=N</samp>&rsquo;.
</p>
<p>At the mpn level, a nail build is neither source nor binary compatible with a
non-nail build, strictly speaking.  But programs acting on limbs only through
the mpn functions are likely to work equally well with either build, and
judicious use of the definitions below should make any program compatible with
either build, at the source level.
</p>
<p>For the higher level routines, meaning <code>mpz</code> etc, a nail build should be
fully source and binary compatible with a non-nail build.
</p>
<dl>
<dt id="index-GMP_005fNAIL_005fBITS">Macro: <strong>GMP_NAIL_BITS</strong></dt>
<dt id="index-GMP_005fNUMB_005fBITS">Macro: <strong>GMP_NUMB_BITS</strong></dt>
<dt id="index-GMP_005fLIMB_005fBITS">Macro: <strong>GMP_LIMB_BITS</strong></dt>
<dd><p><code>GMP_NAIL_BITS</code> is the number of nail bits, or 0 when nails are not in
use.  <code>GMP_NUMB_BITS</code> is the number of data bits in a limb.
<code>GMP_LIMB_BITS</code> is the total number of bits in an <code>mp_limb_t</code>.  In
all cases
</p>
<div class="example">
<pre class="example">GMP_LIMB_BITS == GMP_NAIL_BITS + GMP_NUMB_BITS
</pre></div>
</dd></dl>
<dl>
<dt id="index-GMP_005fNAIL_005fMASK">Macro: <strong>GMP_NAIL_MASK</strong></dt>
<dt id="index-GMP_005fNUMB_005fMASK">Macro: <strong>GMP_NUMB_MASK</strong></dt>
<dd><p>Bit masks for the nail and number parts of a limb.  <code>GMP_NAIL_MASK</code> is 0
when nails are not in use.
</p>
<p><code>GMP_NAIL_MASK</code> is not often needed, since the nail part can be obtained
with <code>x &gt;&gt; GMP_NUMB_BITS</code>, and that means one less large constant, which
can help various RISC chips.
</p></dd></dl>
<dl>
<dt id="index-GMP_005fNUMB_005fMAX">Macro: <strong>GMP_NUMB_MAX</strong></dt>
<dd><p>The maximum value that can be stored in the number part of a limb.  This is
the same as <code>GMP_NUMB_MASK</code>, but can be used for clarity when doing
comparisons rather than bit-wise operations.
</p></dd></dl>
<p>The term &ldquo;nails&rdquo; comes from finger or toe nails, which are at the ends of a
limb (arm or leg).  &ldquo;numb&rdquo; is short for number, but is also how the
developers felt after trying for a long time to come up with sensible names
for these things.
</p>
<p>In the future (the distant future most likely) a non-zero nail might be
permitted, giving non-unique representations for numbers in a limb vector.
This would help vector processors since carries would only ever need to
propagate one or two limbs.
</p>
<hr>
<div class="header">
<p>
Next: <a href="constant.Random_Number_Functions.html#Random-Number-Functions" accesskey="n" rel="next">Random Number Functions</a>, Previous: <a href="constant.Floating_point_Functions.html#Floating_002dpoint-Functions" accesskey="p" rel="prev">Floating-point Functions</a>, Up: <a href="index.html#start" accesskey="u" rel="up">Top</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div></div></details></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="gmp_mpfr_sys" data-search-index-js="../../../search-index.js" data-search-js="../../../search.js"></div>
</body></html>