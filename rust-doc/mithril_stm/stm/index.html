<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Top-level API for Mithril Stake-based Threshold Multisignature scheme. See figure 6 of the paper for most of the protocol."><meta name="keywords" content="rust, rustlang, rust-lang, stm"><title>mithril_stm::stm - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../mithril_stm/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../mithril_stm/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module stm</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Module <a href="../index.html">mithril_stm</a>::<wbr><a class="mod" href="#">stm</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/mithril_stm/stm.rs.html#1-1214">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Top-level API for Mithril Stake-based Threshold Multisignature scheme.
See figure 6 of <a href="https://eprint.iacr.org/2021/916">the paper</a> for most of the
protocol.</p>
<p>What follows is a simple example showing the usage of STM.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>blake2::{Blake2b, digest::consts::U32};
<span class="kw">use </span>mithril_stm::key_reg::KeyReg; <span class="comment">// Import key registration functionality
</span><span class="kw">use </span>mithril_stm::stm::{StmClerk, StmInitializer, StmParameters, StmSig, StmSigner};
<span class="kw">use </span>mithril_stm::AggregationError;
<span class="kw">use </span>rayon::prelude::<span class="kw-2">*</span>; <span class="comment">// We use par_iter to speed things up

</span><span class="kw">use </span>rand_chacha::ChaCha20Rng;
<span class="kw">use </span>rand_core::{RngCore, SeedableRng};

<span class="kw">let </span>nparties = <span class="number">4</span>; <span class="comment">// Use a small number of parties for this example
</span><span class="kw">type </span>D = Blake2b&lt;U32&gt;; <span class="comment">// Setting the hash function for convenience

</span><span class="kw">let </span><span class="kw-2">mut </span>rng = ChaCha20Rng::from_seed([<span class="number">0u8</span>; <span class="number">32</span>]); <span class="comment">// create and initialize rng
</span><span class="kw">let </span><span class="kw-2">mut </span>msg = [<span class="number">0u8</span>; <span class="number">16</span>]; <span class="comment">// setting an arbitrary message
</span>rng.fill_bytes(<span class="kw-2">&amp;mut </span>msg);

<span class="comment">// In the following, we will have 4 parties try to sign `msg`, then aggregate and
// verify those signatures.

//////////////////////////
// initialization phase //
//////////////////////////

// Set low parameters for testing
// XXX: not for production
</span><span class="kw">let </span>params = StmParameters {
    m: <span class="number">100</span>, <span class="comment">// Security parameter XXX: not for production
    </span>k: <span class="number">2</span>, <span class="comment">// Quorum parameter XXX: not for production
    </span>phi_f: <span class="number">0.2</span>, <span class="comment">// Lottery parameter XXX: not for production
</span>};

<span class="comment">// Generate some arbitrary stake for each party
// Stake is an integer.
// Total stake of all parties is total stake in the system.
</span><span class="kw">let </span>stakes = (<span class="number">0</span>..nparties)
    .into_iter()
    .map(|<span class="kw">_</span>| <span class="number">1 </span>+ (rng.next_u64() % <span class="number">9999</span>))
    .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();

<span class="comment">// Create a new key registry from the parties and their stake
</span><span class="kw">let </span><span class="kw-2">mut </span>key_reg = KeyReg::init();

<span class="comment">// For each party, crate a StmInitializer.
// This struct can create keys for the party.
</span><span class="kw">let </span><span class="kw-2">mut </span>ps: Vec&lt;StmInitializer&gt; = Vec::with_capacity(nparties);
<span class="kw">for </span>stake <span class="kw">in </span>stakes {
    <span class="comment">// Create keys for this party
    </span><span class="kw">let </span>p = StmInitializer::setup(params, stake, <span class="kw-2">&amp;mut </span>rng);
    <span class="comment">// Register keys with the KeyReg service
    </span>key_reg
        .register(p.stake, p.verification_key())
        .unwrap();
    ps.push(p);
}

<span class="comment">// Close the key registration.
</span><span class="kw">let </span>closed_reg = key_reg.close();

<span class="comment">// Finalize the StmInitializer and turn it into a StmSigner, which can execute the
// rest of the protocol.
</span><span class="kw">let </span>ps = ps
    .into_par_iter()
    .map(|p| p.new_signer(closed_reg.clone()).unwrap())
    .collect::&lt;Vec&lt;StmSigner&lt;D&gt;&gt;&gt;();

<span class="comment">/////////////////////
// operation phase //
/////////////////////

// Next, each party tries to sign the message for each index available.
// We collect the successful signatures into a vec.
</span><span class="kw">let </span>sigs = ps
    .par_iter()
    .filter_map(|p| {
        <span class="kw">return </span>p.sign(<span class="kw-2">&amp;</span>msg);
    })
    .collect::&lt;Vec&lt;StmSig&gt;&gt;();

<span class="comment">// StmClerk can aggregate and verify signatures.
</span><span class="kw">let </span>clerk = StmClerk::from_signer(<span class="kw-2">&amp;</span>ps[<span class="number">0</span>]);

<span class="comment">// Aggregate and verify the signatures
</span><span class="kw">let </span>msig = clerk.aggregate(<span class="kw-2">&amp;</span>sigs, <span class="kw-2">&amp;</span>msg);
<span class="kw">match </span>msig {
    <span class="prelude-val">Ok</span>(aggr) =&gt; {
        <span class="macro">println!</span>(<span class="string">&quot;Aggregate ok&quot;</span>);
        <span class="macro">assert!</span>(aggr
            .verify(<span class="kw-2">&amp;</span>msg, <span class="kw-2">&amp;</span>clerk.compute_avk(), <span class="kw-2">&amp;</span>params)
            .is_ok());
    }
    <span class="prelude-val">Err</span>(AggregationError::NotEnoughSignatures(n, k)) =&gt; {
        <span class="macro">println!</span>(<span class="string">&quot;Not enough signatures&quot;</span>);
        <span class="macro">assert!</span>(n &lt; params.k &amp;&amp; k == params.k)
    }
    <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">unreachable!</span>(),
}</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StmAggrSig.html" title="mithril_stm::stm::StmAggrSig struct">StmAggrSig</a></div><div class="item-right docblock-short"><code>StmMultiSig</code> uses the “concatenation” proving system (as described in Section 4.3 of the original paper.)
This means that the aggregated signature contains a vector with all individual signatures.
BatchPath is also a part of the aggregate signature which covers path for all signatures.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StmAggrVerificationKey.html" title="mithril_stm::stm::StmAggrVerificationKey struct">StmAggrVerificationKey</a></div><div class="item-right docblock-short">Stm aggregate key (batch compatible), which contains the merkle tree commitment and the total stake of the system.
Batch Compat Merkle tree commitment includes the number of leaves in the tree in order to obtain batch path.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StmClerk.html" title="mithril_stm::stm::StmClerk struct">StmClerk</a></div><div class="item-right docblock-short"><code>StmClerk</code> can verify and aggregate <code>StmSig</code>s and verify <code>StmMultiSig</code>s.
Clerks can only be generated with the registration closed.
This avoids that a Merkle Tree is computed before all parties have registered.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StmInitializer.html" title="mithril_stm::stm::StmInitializer struct">StmInitializer</a></div><div class="item-right docblock-short">Initializer for <code>StmSigner</code>.
This is the data that is used during the key registration procedure.
Once the latter is finished, this instance is consumed into an <code>StmSigner</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StmParameters.html" title="mithril_stm::stm::StmParameters struct">StmParameters</a></div><div class="item-right docblock-short">Used to set protocol parameters.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StmSig.html" title="mithril_stm::stm::StmSig struct">StmSig</a></div><div class="item-right docblock-short">Signature created by a single party who has won the lottery.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StmSigner.html" title="mithril_stm::stm::StmSigner struct">StmSigner</a></div><div class="item-right docblock-short">Participant in the protocol can sign messages.
This instance can only be generated out of an <code>StmInitializer</code> and a <code>ClosedKeyReg</code>.
This ensures that a <code>MerkleTree</code> root is not computed before all participants have registered.</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Index.html" title="mithril_stm::stm::Index type">Index</a></div><div class="item-right docblock-short">Quorum index for signatures.
An aggregate signature (<code>StmMultiSig</code>) must have at least <code>k</code> unique indices.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Stake.html" title="mithril_stm::stm::Stake type">Stake</a></div><div class="item-right docblock-short">The quantity of stake held by a party, represented as a <code>u64</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.StmVerificationKey.html" title="mithril_stm::stm::StmVerificationKey type">StmVerificationKey</a></div><div class="item-right docblock-short">Wrapper of the MultiSignature Verification key</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.StmVerificationKeyPoP.html" title="mithril_stm::stm::StmVerificationKeyPoP type">StmVerificationKeyPoP</a></div><div class="item-right docblock-short">Wrapper of the MultiSignature Verification key with proof of possession</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="mithril_stm" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0 (69f9c33d7 2022-12-12)" ></div></body></html>